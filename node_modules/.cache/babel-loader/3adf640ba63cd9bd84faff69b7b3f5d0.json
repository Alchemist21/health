{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar hub_1 = require(\"./hub\");\n\nexports.connectToGaiaHub = hub_1.connectToGaiaHub;\nexports.uploadToGaiaHub = hub_1.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = hub_1.BLOCKSTACK_GAIA_HUB_LABEL; // export { type GaiaHubConfig } from './hub'\n\nvar ec_1 = require(\"../encryption/ec\");\n\nvar keys_1 = require(\"../keys\");\n\nvar profileLookup_1 = require(\"../profiles/profileLookup\");\n\nvar errors_1 = require(\"../errors\");\n\nvar logger_1 = require(\"../logger\");\n\nvar userSession_1 = require(\"../auth/userSession\");\n\nvar SIGNATURE_FILE_SUFFIX = '.sig';\n/**\r\n * Deletes the specified file from the app's data store. Currently not implemented.\r\n * @param {String} path - the path to the file to delete\r\n * @returns {Promise} that resolves when the file has been removed\r\n * or rejects with an error\r\n */\n\nfunction deleteFile(path) {\n  Promise.reject(new Error(\"Delete of \".concat(path, \" not supported by gaia hubs\")));\n}\n\nexports.deleteFile = deleteFile;\n/**\r\n * Fetch the public read URL of a user file for the specified app.\r\n * @param {String} path - the path to the file to read\r\n * @param {String} username - The Blockstack ID of the user to look up\r\n * @param {String} appOrigin - The app origin\r\n * @param {String} [zoneFileLookupURL=null] - The URL\r\n * to use for zonefile lookup. If falsey, this will use the\r\n * blockstack.js's getNameInfo function instead.\r\n * @return {Promise<string>} that resolves to the public read URL of the file\r\n * or rejects with an error\r\n */\n\nfunction getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var profile, bucketUrl, url, bucket;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return profileLookup_1.lookupProfile(username, zoneFileLookupURL);\n\n          case 2:\n            profile = _context.sent;\n            bucketUrl = null;\n\n            if (profile.hasOwnProperty('apps')) {\n              if (profile.apps.hasOwnProperty(appOrigin)) {\n                url = profile.apps[appOrigin];\n                bucket = url.replace(/\\/?(\\?|#|$)/, '/$1');\n                bucketUrl = \"\".concat(bucket).concat(path);\n              }\n            }\n\n            return _context.abrupt(\"return\", bucketUrl);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.getUserAppFileUrl = getUserAppFileUrl;\n/**\r\n * Encrypts the data provided with the app public key.\r\n * @param {String|Buffer} content - data to encrypt\r\n * @param {Object} [options=null] - options object\r\n * @param {String} options.publicKey - the hex string of the ECDSA public\r\n * key to use for encryption. If not provided, will use user's appPublicKey.\r\n * @return {String} Stringified ciphertext object\r\n */\n\nfunction encryptContent(content, options, caller) {\n  var opts = Object.assign({}, options);\n\n  if (!opts.publicKey) {\n    var privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n    opts.publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n  }\n\n  var cipherObject = ec_1.encryptECIES(opts.publicKey, content);\n  return JSON.stringify(cipherObject);\n}\n\nexports.encryptContent = encryptContent;\n/**\r\n * Decrypts data encrypted with `encryptContent` with the\r\n * transit private key.\r\n * @param {String|Buffer} content - encrypted content.\r\n * @param {Object} [options=null] - options object\r\n * @param {String} options.privateKey - the hex string of the ECDSA private\r\n * key to use for decryption. If not provided, will use user's appPrivateKey.\r\n * @return {String|Buffer} decrypted content.\r\n */\n\nfunction decryptContent(content, options, caller) {\n  var opts = Object.assign({}, options);\n\n  if (!opts.privateKey) {\n    opts.privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n  }\n\n  try {\n    var cipherObject = JSON.parse(content);\n    return ec_1.decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}\n\nexports.decryptContent = decryptContent;\n/* Get the gaia address used for servicing multiplayer reads for the given\r\n * (username, app) pair.\r\n * @private\r\n */\n\nfunction getGaiaAddress(app, username, zoneFileLookupURL, caller) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2() {\n    var opts, fileUrl, gaiaHubConfig, matches;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            opts = normalizeOptions({\n              app: app,\n              username: username\n            }, caller);\n\n            if (!username) {\n              _context2.next = 7;\n              break;\n            }\n\n            _context2.next = 4;\n            return getUserAppFileUrl('/', opts.username, opts.app, zoneFileLookupURL);\n\n          case 4:\n            fileUrl = _context2.sent;\n            _context2.next = 14;\n            break;\n\n          case 7:\n            if (!caller) {\n              caller = new userSession_1.UserSession();\n            }\n\n            _context2.next = 10;\n            return caller.getOrSetLocalGaiaHubConnection();\n\n          case 10:\n            gaiaHubConfig = _context2.sent;\n            _context2.next = 13;\n            return hub_1.getFullReadUrl('/', gaiaHubConfig);\n\n          case 13:\n            fileUrl = _context2.sent;\n\n          case 14:\n            matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n\n            if (matches) {\n              _context2.next = 17;\n              break;\n            }\n\n            throw new Error('Failed to parse gaia address');\n\n          case 17:\n            return _context2.abrupt(\"return\", matches[matches.length - 1]);\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n/**\r\n * @param {Object} [options=null] - options object\r\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\r\n * @param {String} options.app - the app to lookup for multi-player storage -\r\n * defaults to current origin\r\n */\n\n\nfunction normalizeOptions(options, caller) {\n  var opts = Object.assign({}, options);\n\n  if (opts.username) {\n    if (!opts.app) {\n      var appConfig = (caller || new userSession_1.UserSession()).appConfig;\n\n      if (!appConfig) {\n        throw new errors_1.InvalidStateError('Missing AppConfig');\n      }\n\n      opts.app = appConfig.appDomain;\n    }\n  }\n\n  return opts;\n}\n/**\r\n * Get the URL for reading a file from an app's data store.\r\n * @param {String} path - the path to the file to read\r\n * @param {Object} [options=null] - options object\r\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\r\n * @param {String} options.app - the app to lookup for multi-player storage -\r\n * defaults to current origin\r\n * @param {String} [options.zoneFileLookupURL=null] - The URL\r\n * to use for zonefile lookup. If falsey, this will use the\r\n * blockstack.js's getNameInfo function instead.\r\n * @returns {Promise<string>} that resolves to the URL or rejects with an error\r\n */\n\n\nfunction getFileUrl(path, options, caller) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3() {\n    var opts, readUrl, gaiaHubConfig;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            opts = normalizeOptions(options, caller);\n\n            if (!opts.username) {\n              _context3.next = 7;\n              break;\n            }\n\n            _context3.next = 4;\n            return getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);\n\n          case 4:\n            readUrl = _context3.sent;\n            _context3.next = 13;\n            break;\n\n          case 7:\n            _context3.next = 9;\n            return (caller || new userSession_1.UserSession()).getOrSetLocalGaiaHubConnection();\n\n          case 9:\n            gaiaHubConfig = _context3.sent;\n            _context3.next = 12;\n            return hub_1.getFullReadUrl(path, gaiaHubConfig);\n\n          case 12:\n            readUrl = _context3.sent;\n\n          case 13:\n            if (readUrl) {\n              _context3.next = 17;\n              break;\n            }\n\n            throw new Error('Missing readURL');\n\n          case 17:\n            return _context3.abrupt(\"return\", readUrl);\n\n          case 18:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}\n\nexports.getFileUrl = getFileUrl;\n/* Handle fetching the contents from a given path. Handles both\r\n *  multi-player reads and reads from own storage.\r\n * @private\r\n */\n\nfunction getFileContents(path, app, username, zoneFileLookupURL, forceText, caller) {\n  return Promise.resolve().then(function () {\n    var opts = {\n      app: app,\n      username: username,\n      zoneFileLookupURL: zoneFileLookupURL\n    };\n    return getFileUrl(path, opts, caller);\n  }).then(function (readUrl) {\n    return fetch(readUrl);\n  }).then(function (response) {\n    if (response.status !== 200) {\n      if (response.status === 404) {\n        logger_1.Logger.debug(\"getFile \".concat(path, \" returned 404, returning null\"));\n        return null;\n      } else {\n        throw new Error(\"getFile \".concat(path, \" failed with HTTP status \").concat(response.status));\n      }\n    }\n\n    var contentType = response.headers.get('Content-Type');\n\n    if (forceText || contentType === null || contentType.startsWith('text') || contentType === 'application/json') {\n      return response.text();\n    } else {\n      return response.arrayBuffer();\n    }\n  });\n}\n/* Handle fetching an unencrypted file, its associated signature\r\n *  and then validate it. Handles both multi-player reads and reads\r\n *  from own storage.\r\n * @private\r\n */\n\n\nfunction getFileSignedUnencrypted(path, opt, caller) {\n  // future optimization note:\n  //    in the case of _multi-player_ reads, this does a lot of excess\n  //    profile lookups to figure out where to read files\n  //    do browsers cache all these requests if Content-Cache is set?\n  return Promise.all([getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false, caller), getFileContents(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), opt.app, opt.username, opt.zoneFileLookupURL, true, caller), getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL, caller)]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        fileContents = _ref2[0],\n        signatureContents = _ref2[1],\n        gaiaAddress = _ref2[2];\n\n    if (!fileContents) {\n      return fileContents;\n    }\n\n    if (!gaiaAddress) {\n      throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + \"\".concat(path));\n    }\n\n    if (!signatureContents || typeof signatureContents !== 'string') {\n      throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: ' + \"\".concat(path, \" -- looked in \").concat(path).concat(SIGNATURE_FILE_SUFFIX));\n    }\n\n    var signature;\n    var publicKey;\n\n    try {\n      var sigObject = JSON.parse(signatureContents);\n      signature = sigObject.signature;\n      publicKey = sigObject.publicKey;\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse signature content JSON ' + \"(path: \".concat(path).concat(SIGNATURE_FILE_SUFFIX, \")\") + ' The content may be corrupted.');\n      } else {\n        throw err;\n      }\n    }\n\n    var signerAddress = keys_1.publicKeyToAddress(publicKey);\n\n    if (gaiaAddress !== signerAddress) {\n      throw new errors_1.SignatureVerificationError(\"Signer pubkey address (\".concat(signerAddress, \") doesn't\") + \" match gaia address (\".concat(gaiaAddress, \")\"));\n    } else if (!ec_1.verifyECDSA(fileContents, publicKey, signature)) {\n      throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature: ' + \"path: \".concat(path, \", signature: \").concat(path).concat(SIGNATURE_FILE_SUFFIX));\n    } else {\n      return fileContents;\n    }\n  });\n}\n/* Handle signature verification and decryption for contents which are\r\n *  expected to be signed and encrypted. This works for single and\r\n *  multiplayer reads. In the case of multiplayer reads, it uses the\r\n *  gaia address for verification of the claimed public key.\r\n * @private\r\n */\n\n\nfunction handleSignedEncryptedContents(caller, path, storedContents, app, username, zoneFileLookupURL) {\n  var appPrivateKey = caller.loadUserData().appPrivateKey;\n  var appPublicKey = keys_1.getPublicKeyFromPrivate(appPrivateKey);\n  var addressPromise;\n\n  if (username) {\n    addressPromise = getGaiaAddress(app, username, zoneFileLookupURL, caller);\n  } else {\n    var address = keys_1.publicKeyToAddress(appPublicKey);\n    addressPromise = Promise.resolve(address);\n  }\n\n  return addressPromise.then(function (address) {\n    if (!address) {\n      throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + \"\".concat(path));\n    }\n\n    var sigObject;\n\n    try {\n      sigObject = JSON.parse(storedContents);\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse encrypted, signed content JSON. The content may not ' + 'be encrypted. If using getFile, try passing' + ' { verify: false, decrypt: false }.');\n      } else {\n        throw err;\n      }\n    }\n\n    var signature = sigObject.signature;\n    var signerPublicKey = sigObject.publicKey;\n    var cipherText = sigObject.cipherText;\n    var signerAddress = keys_1.publicKeyToAddress(signerPublicKey);\n\n    if (!signerPublicKey || !cipherText || !signature) {\n      throw new errors_1.SignatureVerificationError('Failed to get signature verification data from file:' + \" \".concat(path));\n    } else if (signerAddress !== address) {\n      throw new errors_1.SignatureVerificationError(\"Signer pubkey address (\".concat(signerAddress, \") doesn't\") + \" match gaia address (\".concat(address, \")\"));\n    } else if (!ec_1.verifyECDSA(cipherText, signerPublicKey, signature)) {\n      throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature in file:' + \" \".concat(path));\n    } else {\n      return caller.decryptContent(cipherText);\n    }\n  });\n}\n/**\r\n * Retrieves the specified file from the app's data store.\r\n * @param {String} path - the path to the file to read\r\n * @param {Object} [options=null] - options object\r\n * @param {Boolean} [options.decrypt=true] - try to decrypt the data with the app private key\r\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\r\n * @param {Boolean} options.verify - Whether the content should be verified, only to be used\r\n * when `putFile` was set to `sign = true`\r\n * @param {String} options.app - the app to lookup for multi-player storage -\r\n * defaults to current origin\r\n * @param {String} [options.zoneFileLookupURL=null] - The URL\r\n * to use for zonefile lookup. If falsey, this will use the\r\n * blockstack.js's getNameInfo function instead.\r\n * @returns {Promise} that resolves to the raw data in the file\r\n * or rejects with an error\r\n */\n\n\nfunction getFile(path, options, caller) {\n  var defaults = {\n    decrypt: true,\n    verify: false,\n    username: null,\n    app: typeof window !== 'undefined' ? window.location.origin : undefined,\n    zoneFileLookupURL: null\n  };\n  var opt = Object.assign({}, defaults, options);\n\n  if (!caller) {\n    caller = new userSession_1.UserSession();\n  } // in the case of signature verification, but no\n  //  encryption expected, need to fetch _two_ files.\n\n\n  if (opt.verify && !opt.decrypt) {\n    return getFileSignedUnencrypted(path, opt, caller);\n  }\n\n  return getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt, caller).then(function (storedContents) {\n    if (storedContents === null) {\n      return storedContents;\n    } else if (opt.decrypt && !opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return caller.decryptContent(storedContents);\n    } else if (opt.decrypt && opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return handleSignedEncryptedContents(caller, path, storedContents, opt.app, opt.username, opt.zoneFileLookupURL);\n    } else if (!opt.verify && !opt.decrypt) {\n      return storedContents;\n    } else {\n      throw new Error('Should be unreachable.');\n    }\n  });\n}\n\nexports.getFile = getFile;\n/**\r\n * Stores the data provided in the app's data store to to the file specified.\r\n * @param {String} path - the path to store the data in\r\n * @param {String|Buffer} content - the data to store in the file\r\n * @param {Object} [options=null] - options object\r\n * @param {Boolean|String} [options.encrypt=true] - encrypt the data with the app public key\r\n *                                                  or the provided public key\r\n * @param {Boolean} [options.sign=false] - sign the data using ECDSA on SHA256 hashes with\r\n *                                         the app private key\r\n * @param {String} [options.contentType=''] - set a Content-Type header for unencrypted data\r\n * @return {Promise} that resolves if the operation succeed and rejects\r\n * if it failed\r\n */\n\nfunction putFile(path, content, options, caller) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4() {\n    var defaults, opt, contentType, privateKey, publicKey, signatureObject, signatureContent, _gaiaHubConfig, fileUrls, freshHubConfig, _fileUrls, cipherText, _signatureObject, signedCipherObject, gaiaHubConfig, _freshHubConfig, file;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            defaults = {\n              encrypt: true,\n              sign: false,\n              contentType: ''\n            };\n            opt = Object.assign({}, defaults, options);\n            contentType = opt.contentType;\n\n            if (!contentType) {\n              contentType = typeof content === 'string' ? 'text/plain; charset=utf-8' : 'application/octet-stream';\n            }\n\n            if (!caller) {\n              caller = new userSession_1.UserSession();\n            } // First, let's figure out if we need to get public/private keys,\n            //  or if they were passed in\n\n\n            privateKey = '';\n            publicKey = '';\n\n            if (opt.sign) {\n              if (typeof opt.sign === 'string') {\n                privateKey = opt.sign;\n              } else {\n                privateKey = caller.loadUserData().appPrivateKey;\n              }\n            }\n\n            if (opt.encrypt) {\n              if (typeof opt.encrypt === 'string') {\n                publicKey = opt.encrypt;\n              } else {\n                if (!privateKey) {\n                  privateKey = caller.loadUserData().appPrivateKey;\n                }\n\n                publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n              }\n            } // In the case of signing, but *not* encrypting,\n            //   we perform two uploads. So the control-flow\n            //   here will return there.\n\n\n            if (!(!opt.encrypt && opt.sign)) {\n              _context4.next = 31;\n              break;\n            }\n\n            signatureObject = ec_1.signECDSA(privateKey, content);\n            signatureContent = JSON.stringify(signatureObject);\n            _context4.next = 14;\n            return caller.getOrSetLocalGaiaHubConnection();\n\n          case 14:\n            _gaiaHubConfig = _context4.sent;\n            _context4.prev = 15;\n            _context4.next = 18;\n            return Promise.all([hub_1.uploadToGaiaHub(path, content, _gaiaHubConfig, contentType), hub_1.uploadToGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), signatureContent, _gaiaHubConfig, 'application/json')]);\n\n          case 18:\n            fileUrls = _context4.sent;\n            return _context4.abrupt(\"return\", fileUrls[0]);\n\n          case 22:\n            _context4.prev = 22;\n            _context4.t0 = _context4[\"catch\"](15);\n            _context4.next = 26;\n            return caller.setLocalGaiaHubConnection();\n\n          case 26:\n            freshHubConfig = _context4.sent;\n            _context4.next = 29;\n            return Promise.all([hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType), hub_1.uploadToGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), signatureContent, freshHubConfig, 'application/json')]);\n\n          case 29:\n            _fileUrls = _context4.sent;\n            return _context4.abrupt(\"return\", _fileUrls[0]);\n\n          case 31:\n            // In all other cases, we only need one upload.\n            if (opt.encrypt && !opt.sign) {\n              content = encryptContent(content, {\n                publicKey: publicKey\n              });\n              contentType = 'application/json';\n            } else if (opt.encrypt && opt.sign) {\n              cipherText = encryptContent(content, {\n                publicKey: publicKey\n              });\n              _signatureObject = ec_1.signECDSA(privateKey, cipherText);\n              signedCipherObject = {\n                signature: _signatureObject.signature,\n                publicKey: _signatureObject.publicKey,\n                cipherText: cipherText\n              };\n              content = JSON.stringify(signedCipherObject);\n              contentType = 'application/json';\n            }\n\n            _context4.next = 34;\n            return caller.getOrSetLocalGaiaHubConnection();\n\n          case 34:\n            gaiaHubConfig = _context4.sent;\n            _context4.prev = 35;\n            _context4.next = 38;\n            return hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType);\n\n          case 38:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 41:\n            _context4.prev = 41;\n            _context4.t1 = _context4[\"catch\"](35);\n            _context4.next = 45;\n            return caller.setLocalGaiaHubConnection();\n\n          case 45:\n            _freshHubConfig = _context4.sent;\n            _context4.next = 48;\n            return hub_1.uploadToGaiaHub(path, content, _freshHubConfig, contentType);\n\n          case 48:\n            file = _context4.sent;\n            return _context4.abrupt(\"return\", file);\n\n          case 50:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[15, 22], [35, 41]]);\n  }));\n}\n\nexports.putFile = putFile;\n/**\r\n * Get the app storage bucket URL\r\n * @param {String} gaiaHubUrl - the gaia hub URL\r\n * @param {String} appPrivateKey - the app private key used to generate the app address\r\n * @returns {Promise} That resolves to the URL of the app index file\r\n * or rejects if it fails\r\n */\n\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n  return hub_1.getBucketUrl(gaiaHubUrl, appPrivateKey);\n}\n\nexports.getAppBucketUrl = getAppBucketUrl;\n/**\r\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\r\n * Not meant to be called by external clients.\r\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\r\n * @param {String | null} page - the page ID\r\n * @param {number} callCount - the loop count\r\n * @param {number} fileCount - the number of files listed so far\r\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\r\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\r\n * @returns {Promise} that resolves to the number of files listed.\r\n * @private\r\n */\n\nfunction listFilesLoop(hubConfig, page, callCount, fileCount, callback) {\n  if (callCount > 65536) {\n    // this is ridiculously huge, and probably indicates\n    // a faulty Gaia hub anyway (e.g. on that serves endless data)\n    throw new Error('Too many entries to list');\n  }\n\n  var httpStatus;\n  var pageRequest = JSON.stringify({\n    page: page\n  });\n  var fetchOptions = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': \"\".concat(pageRequest.length),\n      Authorization: \"bearer \".concat(hubConfig.token)\n    },\n    body: pageRequest\n  };\n  return fetch(\"\".concat(hubConfig.server, \"/list-files/\").concat(hubConfig.address), fetchOptions).then(function (response) {\n    httpStatus = response.status;\n\n    if (httpStatus >= 400) {\n      throw new Error(\"listFiles failed with HTTP status \".concat(httpStatus));\n    }\n\n    return response.text();\n  }).then(function (responseText) {\n    return JSON.parse(responseText);\n  }).then(function (responseJSON) {\n    var entries = responseJSON.entries;\n    var nextPage = responseJSON.page;\n\n    if (entries === null || entries === undefined) {\n      // indicates a misbehaving Gaia hub or a misbehaving driver\n      // (i.e. the data is malformed)\n      throw new Error('Bad listFiles response: no entries');\n    }\n\n    for (var i = 0; i < entries.length; i++) {\n      var rc = callback(entries[i]);\n\n      if (!rc) {\n        // callback indicates that we're done\n        return Promise.resolve(fileCount + i);\n      }\n    }\n\n    if (nextPage && entries.length > 0) {\n      // keep going -- have more entries\n      return listFilesLoop(hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback);\n    } else {\n      // no more entries -- end of data\n      return Promise.resolve(fileCount + entries.length);\n    }\n  });\n}\n/**\r\n * List the set of files in this application's Gaia storage bucket.\r\n * @param {UserSession} caller - instance calling this method\r\n * @param {function} callback - a callback to invoke on each named file that\r\n * returns `true` to continue the listing operation or `false` to end it\r\n * @return {Promise} that resolves to the number of files listed\r\n */\n\n\nfunction listFiles(callback, caller) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5() {\n    var userSession, gaiaHubConfig;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            userSession = caller || new userSession_1.UserSession();\n            _context5.next = 3;\n            return userSession.getOrSetLocalGaiaHubConnection();\n\n          case 3:\n            gaiaHubConfig = _context5.sent;\n            return _context5.abrupt(\"return\", listFilesLoop(gaiaHubConfig, null, 0, 0, callback));\n\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n}\n\nexports.listFiles = listFiles;","map":null,"metadata":{},"sourceType":"script"}