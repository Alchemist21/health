{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar query_string_1 = __importDefault(require(\"query-string\")); // @ts-ignore: Could not find a declaration file for module\n\n\nvar jsontokens_1 = require(\"jsontokens\");\n\nvar authVerification_1 = require(\"./authVerification\");\n\nvar utils_1 = require(\"../utils\");\n\nvar dids_1 = require(\"../dids\");\n\nvar errors_1 = require(\"../errors\");\n\nvar authMessages_1 = require(\"./authMessages\");\n\nvar authConstants_1 = require(\"./authConstants\");\n\nvar profileTokens_1 = require(\"../profiles/profileTokens\");\n\nvar userSession_1 = require(\"./userSession\");\n\nvar config_1 = require(\"../config\");\n\nvar logger_1 = require(\"../logger\");\n\nvar protocolEchoDetection_1 = require(\"./protocolEchoDetection\");\n\nvar protocolLaunch_1 = require(\"./protocolLaunch\");\n\nvar DEFAULT_PROFILE = {\n  '@type': 'Person',\n  '@context': 'http://schema.org'\n};\n/**\n * Check if a user is currently signed in.\n * @method isUserSignedIn\n * @return {Boolean} `true` if the user is signed in, `false` if not.\n */\n\nfunction isUserSignedIn() {\n  console.warn('DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method isUserSignedIn().');\n  var userSession = new userSession_1.UserSession();\n  return userSession.isUserSignedIn();\n}\n\nexports.isUserSignedIn = isUserSignedIn;\n/**\n * Generates an authentication request and redirects the user to the Blockstack\n * browser to approve the sign in request.\n *\n * Please note that this requires that the web browser properly handles the\n * `blockstack:` URL protocol handler.\n *\n * Most applications should use this\n * method for sign in unless they require more fine grained control over how the\n * authentication request is generated. If your app falls into this category,\n * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.\n *\n * @param {String} [redirectURI=`${window.location.origin}/`]\n * The location to which the identity provider will redirect the user after\n * the user approves sign in.\n * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]\n * Location of the manifest file.\n * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to\n * this app's data store.\n * An array of strings indicating which permissions this app is requesting.\n * @return {void}\n */\n\nfunction redirectToSignIn(redirectURI, manifestURI, scopes) {\n  console.warn('DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method redirectToSignIn().');\n  var authRequest = authMessages_1.makeAuthRequest(null, redirectURI, manifestURI, scopes);\n  redirectToSignInWithAuthRequest(authRequest);\n}\n\nexports.redirectToSignIn = redirectToSignIn;\n/**\n * Check if there is a authentication request that hasn't been handled.\n * Also checks for a protocol echo reply (which if detected then the page\n * will be automatically redirected after this call).\n * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n */\n\nfunction isSignInPending() {\n  try {\n    var isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n\n    if (isProtocolEcho) {\n      logger_1.Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n      return true;\n    }\n  } catch (error) {\n    logger_1.Logger.error(\"Error checking for protocol echo reply isSignInPending: \".concat(error));\n  }\n\n  return !!getAuthResponseToken();\n}\n\nexports.isSignInPending = isSignInPending;\n/**\n * Retrieve the authentication token from the URL query\n * @return {String} the authentication token if it exists otherwise `null`\n */\n\nfunction getAuthResponseToken() {\n  utils_1.checkWindowAPI('getAuthResponseToken', 'location');\n  var queryDict = query_string_1.default.parse(window.location.search);\n  return queryDict.authResponse ? queryDict.authResponse : '';\n}\n\nexports.getAuthResponseToken = getAuthResponseToken;\n/**\n * Retrieves the user data object. The user's profile is stored in the key `profile`.\n * @return {Object} User data object.\n */\n\nfunction loadUserData() {\n  console.warn('DEPRECATION WARNING: The static loadUserData() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method loadUserData().');\n  var userSession = new userSession_1.UserSession();\n  return userSession.loadUserData();\n}\n\nexports.loadUserData = loadUserData;\n/**\n * Sign the user out and optionally redirect to given location.\n * @param  redirectURL\n * Location to redirect user to after sign out.\n * Only used in environments with `window` available\n */\n\nfunction signUserOut(redirectURL, caller) {\n  var userSession = caller || new userSession_1.UserSession();\n  userSession.store.deleteSessionData();\n\n  if (redirectURL) {\n    if (typeof window !== 'undefined') {\n      window.location.href = redirectURL;\n    } else {\n      var errMsg = '`signUserOut` called with `redirectURL` specified' + \" (\\\"\".concat(redirectURL, \"\\\")\") + ' but `window.location.href` is not available in this environment';\n      logger_1.Logger.error(errMsg);\n      throw new Error(errMsg);\n    }\n  }\n}\n\nexports.signUserOut = signUserOut;\n/**\n * Redirects the user to the Blockstack browser to approve the sign in request\n * given.\n *\n * The user is redirected to the `blockstackIDHost` if the `blockstack:`\n * protocol handler is not detected. Please note that the protocol handler detection\n * does not work on all browsers.\n * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`\n * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack\n *                                     protocol handler is not detected\n * @return {void}\n */\n\nfunction redirectToSignInWithAuthRequest(authRequest) {\n  var blockstackIDHost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : authConstants_1.DEFAULT_BLOCKSTACK_HOST;\n  authRequest = authRequest || authMessages_1.makeAuthRequest();\n  var httpsURI = \"\".concat(blockstackIDHost, \"?authRequest=\").concat(authRequest);\n  utils_1.checkWindowAPI('redirectToSignInWithAuthRequest', 'navigator');\n  utils_1.checkWindowAPI('redirectToSignInWithAuthRequest', 'location'); // If they're on a mobile OS, always redirect them to HTTPS site\n\n  if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(window.navigator.userAgent)) {\n    logger_1.Logger.info('detected mobile OS, sending to https');\n    window.location.href = httpsURI;\n    return;\n  }\n\n  function successCallback() {\n    logger_1.Logger.info('protocol handler detected'); // The detection function should open the link for us\n  }\n\n  function failCallback() {\n    logger_1.Logger.warn('protocol handler not detected');\n    window.location.href = httpsURI;\n  }\n\n  protocolLaunch_1.launchCustomProtocol(authRequest, successCallback, failCallback);\n}\n\nexports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;\n/**\n * Try to process any pending sign in request by returning a `Promise` that resolves\n * to the user data object if the sign in succeeds.\n *\n * @param {String} nameLookupURL - the endpoint against which to verify public\n * keys match claimed username\n * @param {String} authResponseToken - the signed authentication response token\n * @param {String} transitKey - the transit private key that corresponds to the transit public key\n * that was provided in the authentication request\n * @return {Promise} that resolves to the user data object if successful and rejects\n * if handling the sign in request fails or there was no pending sign in request.\n */\n\nfunction handlePendingSignIn() {\n  var nameLookupURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var authResponseToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getAuthResponseToken();\n  var transitKey = arguments.length > 2 ? arguments[2] : undefined;\n  var caller = arguments.length > 3 ? arguments[3] : undefined;\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var isProtocolEcho, msg, _tokenPayload, isValid, tokenPayload, appPrivateKey, coreSessionToken, hubUrl, gaiaAssociationToken, userData, profileURL, response, responseText, wrappedProfile, profile, sessionData;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n\n            if (!isProtocolEcho) {\n              _context.next = 6;\n              break;\n            }\n\n            msg = 'handlePendingSignIn called while protocolEchoReply was detected, and ' + 'the page is about to redirect. This function will resolve with an error after ' + 'several seconds, if the page was not redirected for some reason.';\n            logger_1.Logger.info(msg);\n            return _context.abrupt(\"return\", new Promise(function (_resolve, reject) {\n              setTimeout(function () {\n                logger_1.Logger.error('Page should have redirected by now. handlePendingSignIn will now throw.');\n                reject(msg);\n              }, 3000);\n            }));\n\n          case 6:\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](0);\n            logger_1.Logger.error(\"Error checking for protocol echo reply handlePendingSignIn: \".concat(_context.t0));\n\n          case 11:\n            if (!caller) {\n              caller = new userSession_1.UserSession();\n            }\n\n            if (!transitKey) {\n              transitKey = caller.store.getSessionData().transitKey;\n            }\n\n            if (!nameLookupURL) {\n              _tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n\n              if (utils_1.isLaterVersion(_tokenPayload.version, '1.3.0') && _tokenPayload.blockstackAPIUrl !== null && _tokenPayload.blockstackAPIUrl !== undefined) {\n                // override globally\n                logger_1.Logger.info(\"Overriding \".concat(config_1.config.network.blockstackAPIUrl, \" \") + \"with \".concat(_tokenPayload.blockstackAPIUrl));\n                config_1.config.network.blockstackAPIUrl = _tokenPayload.blockstackAPIUrl;\n              }\n\n              nameLookupURL = \"\".concat(config_1.config.network.blockstackAPIUrl).concat(authConstants_1.NAME_LOOKUP_PATH);\n            }\n\n            _context.next = 16;\n            return authVerification_1.verifyAuthResponse(authResponseToken, nameLookupURL);\n\n          case 16:\n            isValid = _context.sent;\n\n            if (isValid) {\n              _context.next = 19;\n              break;\n            }\n\n            throw new errors_1.LoginFailedError('Invalid authentication response.');\n\n          case 19:\n            tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload; // TODO: real version handling\n\n            appPrivateKey = tokenPayload.private_key;\n            coreSessionToken = tokenPayload.core_token;\n\n            if (!utils_1.isLaterVersion(tokenPayload.version, '1.1.0')) {\n              _context.next = 43;\n              break;\n            }\n\n            if (!(transitKey !== undefined && transitKey != null)) {\n              _context.next = 42;\n              break;\n            }\n\n            if (!(tokenPayload.private_key !== undefined && tokenPayload.private_key !== null)) {\n              _context.next = 39;\n              break;\n            }\n\n            _context.prev = 25;\n            appPrivateKey = authMessages_1.decryptPrivateKey(transitKey, tokenPayload.private_key);\n            _context.next = 39;\n            break;\n\n          case 29:\n            _context.prev = 29;\n            _context.t1 = _context[\"catch\"](25);\n            logger_1.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n            _context.prev = 32;\n            utils_1.hexStringToECPair(tokenPayload.private_key);\n            _context.next = 39;\n            break;\n\n          case 36:\n            _context.prev = 36;\n            _context.t2 = _context[\"catch\"](32);\n            throw new errors_1.LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n\n          case 39:\n            if (coreSessionToken !== undefined && coreSessionToken !== null) {\n              try {\n                coreSessionToken = authMessages_1.decryptPrivateKey(transitKey, coreSessionToken);\n              } catch (e) {\n                logger_1.Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n              }\n            }\n\n            _context.next = 43;\n            break;\n\n          case 42:\n            throw new errors_1.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n\n          case 43:\n            hubUrl = authConstants_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n\n            if (utils_1.isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n              hubUrl = tokenPayload.hubUrl;\n            }\n\n            if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n              gaiaAssociationToken = tokenPayload.associationToken;\n            }\n\n            userData = {\n              username: tokenPayload.username,\n              profile: tokenPayload.profile,\n              email: tokenPayload.email,\n              decentralizedID: tokenPayload.iss,\n              identityAddress: dids_1.getAddressFromDID(tokenPayload.iss),\n              appPrivateKey: appPrivateKey,\n              coreSessionToken: coreSessionToken,\n              authResponseToken: authResponseToken,\n              hubUrl: hubUrl,\n              gaiaAssociationToken: gaiaAssociationToken\n            };\n            profileURL = tokenPayload.profile_url;\n\n            if (!(!userData.profile && profileURL)) {\n              _context.next = 64;\n              break;\n            }\n\n            _context.next = 51;\n            return fetch(profileURL);\n\n          case 51:\n            response = _context.sent;\n\n            if (response.ok) {\n              _context.next = 56;\n              break;\n            }\n\n            // return blank profile if we fail to fetch\n            userData.profile = Object.assign({}, DEFAULT_PROFILE);\n            _context.next = 62;\n            break;\n\n          case 56:\n            _context.next = 58;\n            return response.text();\n\n          case 58:\n            responseText = _context.sent;\n            wrappedProfile = JSON.parse(responseText);\n            profile = profileTokens_1.extractProfile(wrappedProfile[0].token);\n            userData.profile = profile;\n\n          case 62:\n            _context.next = 65;\n            break;\n\n          case 64:\n            userData.profile = tokenPayload.profile;\n\n          case 65:\n            sessionData = caller.store.getSessionData();\n            sessionData.userData = userData;\n            caller.store.setSessionData(sessionData);\n            return _context.abrupt(\"return\", userData);\n\n          case 69:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 8], [25, 29], [32, 36]]);\n  }));\n}\n\nexports.handlePendingSignIn = handlePendingSignIn;","map":null,"metadata":{},"sourceType":"script"}