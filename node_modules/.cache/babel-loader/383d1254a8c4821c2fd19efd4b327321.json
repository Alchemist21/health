{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = __importDefault(require(\"crypto\"));\n\nvar bip39_1 = __importDefault(require(\"bip39\"));\n\nvar triplesec_1 = __importDefault(require(\"triplesec\"));\n/**\n * Encrypt a raw mnemonic phrase to be password protected\n * @param {string} phrase - Raw mnemonic phrase\n * @param {string} password - Password to encrypt mnemonic with\n * @return {Promise<Buffer>} The encrypted phrase\n * @private\n */\n\n\nfunction encryptMnemonic(phrase, password) {\n  return Promise.resolve().then(function () {\n    // must be bip39 mnemonic\n    if (!bip39_1.default.validateMnemonic(phrase)) {\n      throw new Error('Not a valid bip39 nmemonic');\n    } // normalize plaintext to fixed length byte string\n\n\n    var plaintextNormalized = Buffer.from(bip39_1.default.mnemonicToEntropy(phrase), 'hex'); // AES-128-CBC with SHA256 HMAC\n\n    var salt = crypto_1.default.randomBytes(16);\n    var keysAndIV = crypto_1.default.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n    var encKey = keysAndIV.slice(0, 16);\n    var macKey = keysAndIV.slice(16, 32);\n    var iv = keysAndIV.slice(32, 48);\n    var cipher = crypto_1.default.createCipheriv('aes-128-cbc', encKey, iv);\n    var cipherText = cipher.update(plaintextNormalized).toString('hex');\n    cipherText += cipher.final().toString('hex');\n    var hmacPayload = Buffer.concat([salt, Buffer.from(cipherText, 'hex')]);\n    var hmac = crypto_1.default.createHmac('sha256', macKey);\n    hmac.write(hmacPayload);\n    var hmacDigest = hmac.digest();\n    var payload = Buffer.concat([salt, hmacDigest, Buffer.from(cipherText, 'hex')]);\n    return payload;\n  });\n}\n\nexports.encryptMnemonic = encryptMnemonic; // Used to distinguish bad password during decrypt vs invalid format\n\nvar PasswordError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(PasswordError, _Error);\n\n  function PasswordError() {\n    _classCallCheck(this, PasswordError);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PasswordError).apply(this, arguments));\n  }\n\n  return PasswordError;\n}(_wrapNativeSuper(Error));\n\nfunction decryptMnemonicBuffer(dataBuffer, password) {\n  return Promise.resolve().then(function () {\n    var salt = dataBuffer.slice(0, 16);\n    var hmacSig = dataBuffer.slice(16, 48); // 32 bytes\n\n    var cipherText = dataBuffer.slice(48);\n    var hmacPayload = Buffer.concat([salt, cipherText]);\n    var keysAndIV = crypto_1.default.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n    var encKey = keysAndIV.slice(0, 16);\n    var macKey = keysAndIV.slice(16, 32);\n    var iv = keysAndIV.slice(32, 48);\n    var decipher = crypto_1.default.createDecipheriv('aes-128-cbc', encKey, iv);\n    var plaintext = decipher.update(cipherText).toString('hex');\n    plaintext += decipher.final().toString('hex');\n    var hmac = crypto_1.default.createHmac('sha256', macKey);\n    hmac.write(hmacPayload);\n    var hmacDigest = hmac.digest(); // hash both hmacSig and hmacDigest so string comparison time\n    // is uncorrelated to the ciphertext\n\n    var hmacSigHash = crypto_1.default.createHash('sha256').update(hmacSig).digest().toString('hex');\n    var hmacDigestHash = crypto_1.default.createHash('sha256').update(hmacDigest).digest().toString('hex');\n\n    if (hmacSigHash !== hmacDigestHash) {\n      // not authentic\n      throw new PasswordError('Wrong password (HMAC mismatch)');\n    }\n\n    var mnemonic = bip39_1.default.entropyToMnemonic(plaintext);\n\n    if (!bip39_1.default.validateMnemonic(mnemonic)) {\n      throw new PasswordError('Wrong password (invalid plaintext)');\n    }\n\n    return mnemonic;\n  });\n}\n/**\n * Decrypt legacy triplesec keys\n * @param {Buffer} dataBuffer - The encrypted key\n * @param {String} password - Password for data\n * @return {Promise<Buffer>} Decrypted seed\n * @private\n */\n\n\nfunction decryptLegacy(dataBuffer, password) {\n  return new Promise(function (resolve, reject) {\n    triplesec_1.default.decrypt({\n      key: Buffer.from(password),\n      data: dataBuffer\n    }, function (err, plaintextBuffer) {\n      if (!err) {\n        resolve(plaintextBuffer);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n/**\n * Encrypt a raw mnemonic phrase with a password\n * @param {string | Buffer} data - Buffer or hex-encoded string of the encrypted mnemonic\n * @param {string} password - Password for data\n * @return {Promise<string>} the raw mnemonic phrase\n * @private\n */\n\n\nfunction decryptMnemonic(data, password) {\n  var dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n  return decryptMnemonicBuffer(dataBuffer, password).catch(function (err) {\n    // If it was a password error, don't even bother with legacy\n    if (err instanceof PasswordError) {\n      throw err;\n    }\n\n    return decryptLegacy(dataBuffer, password).then(function (data) {\n      return data.toString();\n    });\n  });\n}\n\nexports.decryptMnemonic = decryptMnemonic;","map":null,"metadata":{},"sourceType":"script"}