{"ast":null,"code":"\"use strict\";\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bitcoinjs_lib_1 = __importDefault(require(\"bitcoinjs-lib\"));\n\nvar form_data_1 = __importDefault(require(\"form-data\"));\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar ripemd160_1 = __importDefault(require(\"ripemd160\"));\n\nvar errors_1 = require(\"./errors\");\n\nvar logger_1 = require(\"./logger\");\n\nvar SATOSHIS_PER_BTC = 1e8;\nvar TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT = 'zone-file';\nvar TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT = 'registration';\nvar TX_BROADCAST_SERVICE_TX_ENDPOINT = 'transaction';\n\nvar BitcoinNetwork =\n/*#__PURE__*/\nfunction () {\n  function BitcoinNetwork() {\n    _classCallCheck(this, BitcoinNetwork);\n  }\n\n  _createClass(BitcoinNetwork, [{\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      return Promise.reject(new Error(\"Not implemented, broadcastTransaction(\".concat(transaction, \")\")));\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      return Promise.reject(new Error('Not implemented, getBlockHeight()'));\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txid) {\n      return Promise.reject(new Error(\"Not implemented, getTransactionInfo(\".concat(txid, \")\")));\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      return Promise.reject(new Error(\"Not implemented, getNetworkedUTXOs(\".concat(address, \")\")));\n    }\n  }]);\n\n  return BitcoinNetwork;\n}();\n\nexports.BitcoinNetwork = BitcoinNetwork;\n\nvar BlockstackNetwork =\n/*#__PURE__*/\nfunction () {\n  function BlockstackNetwork(apiUrl, broadcastServiceUrl, bitcoinAPI) {\n    var network = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : bitcoinjs_lib_1.default.networks.bitcoin;\n\n    _classCallCheck(this, BlockstackNetwork);\n\n    this.blockstackAPIUrl = apiUrl;\n    this.broadcastServiceUrl = broadcastServiceUrl;\n    this.layer1 = network;\n    this.btc = bitcoinAPI;\n    this.DUST_MINIMUM = 5500;\n    this.includeUtxoMap = {};\n    this.excludeUtxoSet = [];\n    this.MAGIC_BYTES = 'id';\n  }\n\n  _createClass(BlockstackNetwork, [{\n    key: \"coerceAddress\",\n    value: function coerceAddress(address) {\n      var _bitcoinjs_lib_1$defa = bitcoinjs_lib_1.default.address.fromBase58Check(address),\n          hash = _bitcoinjs_lib_1$defa.hash,\n          version = _bitcoinjs_lib_1$defa.version;\n\n      var scriptHashes = [bitcoinjs_lib_1.default.networks.bitcoin.scriptHash, bitcoinjs_lib_1.default.networks.testnet.scriptHash];\n      var pubKeyHashes = [bitcoinjs_lib_1.default.networks.bitcoin.pubKeyHash, bitcoinjs_lib_1.default.networks.testnet.pubKeyHash];\n      var coercedVersion;\n\n      if (scriptHashes.indexOf(version) >= 0) {\n        coercedVersion = this.layer1.scriptHash;\n      } else if (pubKeyHashes.indexOf(version) >= 0) {\n        coercedVersion = this.layer1.pubKeyHash;\n      } else {\n        throw new Error(\"Unrecognized address version number \".concat(version, \" in \").concat(address));\n      }\n\n      return bitcoinjs_lib_1.default.address.toBase58Check(hash, coercedVersion);\n    }\n  }, {\n    key: \"getDefaultBurnAddress\",\n    value: function getDefaultBurnAddress() {\n      return this.coerceAddress('1111111111111111111114oLvT2');\n    }\n    /**\r\n     * Get the price of a name via the legacy /v1/prices API endpoint.\r\n     * @param {String} fullyQualifiedName the name to query\r\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getNamePriceV1\",\n    value: function getNamePriceV1(fullyQualifiedName) {\n      var _this = this;\n\n      // legacy code path\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/prices/names/\").concat(fullyQualifiedName)).then(function (resp) {\n        if (!resp.ok) {\n          throw new Error(\"Failed to query name price for \".concat(fullyQualifiedName));\n        }\n\n        return resp;\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (resp) {\n        return resp.name_price;\n      }).then(function (namePrice) {\n        if (!namePrice || !namePrice.satoshis) {\n          throw new Error(\"Failed to get price for \".concat(fullyQualifiedName, \". Does the namespace exist?\"));\n        }\n\n        if (namePrice.satoshis < _this.DUST_MINIMUM) {\n          namePrice.satoshis = _this.DUST_MINIMUM;\n        }\n\n        var result = {\n          units: 'BTC',\n          amount: new bn_js_1.default(String(namePrice.satoshis))\n        };\n        return result;\n      });\n    }\n    /**\r\n     * Get the price of a namespace via the legacy /v1/prices API endpoint.\r\n     * @param {String} namespaceID the namespace to query\r\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getNamespacePriceV1\",\n    value: function getNamespacePriceV1(namespaceID) {\n      var _this2 = this;\n\n      // legacy code path\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/prices/namespaces/\").concat(namespaceID)).then(function (resp) {\n        if (!resp.ok) {\n          throw new Error(\"Failed to query name price for \".concat(namespaceID));\n        }\n\n        return resp;\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (namespacePrice) {\n        if (!namespacePrice || !namespacePrice.satoshis) {\n          throw new Error(\"Failed to get price for \".concat(namespaceID));\n        }\n\n        if (namespacePrice.satoshis < _this2.DUST_MINIMUM) {\n          namespacePrice.satoshis = _this2.DUST_MINIMUM;\n        }\n\n        var result = {\n          units: 'BTC',\n          amount: new bn_js_1.default(String(namespacePrice.satoshis))\n        };\n        return result;\n      });\n    }\n    /**\r\n     * Get the price of a name via the /v2/prices API endpoint.\r\n     * @param {String} fullyQualifiedName the name to query\r\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getNamePriceV2\",\n    value: function getNamePriceV2(fullyQualifiedName) {\n      var _this3 = this;\n\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v2/prices/names/\").concat(fullyQualifiedName)).then(function (resp) {\n        if (resp.status !== 200) {\n          // old core node \n          throw new Error('The upstream node does not handle the /v2/ price namespace');\n        }\n\n        return resp;\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (resp) {\n        return resp.name_price;\n      }).then(function (namePrice) {\n        if (!namePrice) {\n          throw new Error(\"Failed to get price for \".concat(fullyQualifiedName, \". Does the namespace exist?\"));\n        }\n\n        var result = {\n          units: namePrice.units,\n          amount: new bn_js_1.default(namePrice.amount)\n        };\n\n        if (namePrice.units === 'BTC') {\n          // must be at least dust-minimum\n          var dustMin = new bn_js_1.default(String(_this3.DUST_MINIMUM));\n\n          if (result.amount.ucmp(dustMin) < 0) {\n            result.amount = dustMin;\n          }\n        }\n\n        return result;\n      });\n    }\n    /**\r\n     * Get the price of a namespace via the /v2/prices API endpoint.\r\n     * @param {String} namespaceID the namespace to query\r\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\r\n     * @private\r\n     */\n\n  }, {\n    key: \"getNamespacePriceV2\",\n    value: function getNamespacePriceV2(namespaceID) {\n      var _this4 = this;\n\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v2/prices/namespaces/\").concat(namespaceID)).then(function (resp) {\n        if (resp.status !== 200) {\n          // old core node \n          throw new Error('The upstream node does not handle the /v2/ price namespace');\n        }\n\n        return resp;\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (namespacePrice) {\n        if (!namespacePrice) {\n          throw new Error(\"Failed to get price for \".concat(namespaceID));\n        }\n\n        var result = {\n          units: namespacePrice.units,\n          amount: new bn_js_1.default(namespacePrice.amount)\n        };\n\n        if (namespacePrice.units === 'BTC') {\n          // must be at least dust-minimum\n          var dustMin = new bn_js_1.default(String(_this4.DUST_MINIMUM));\n\n          if (result.amount.ucmp(dustMin) < 0) {\n            result.amount = dustMin;\n          }\n        }\n\n        return result;\n      });\n    }\n    /**\r\n     * Get the price of a name.\r\n     * @param {String} fullyQualifiedName the name to query\r\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where\r\n     *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\r\n     *   .amount encodes the number of units, in the smallest denominiated amount\r\n     *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\r\n     *   .amount will be microStacks)\r\n     */\n\n  }, {\n    key: \"getNamePrice\",\n    value: function getNamePrice(fullyQualifiedName) {\n      var _this5 = this;\n\n      // handle v1 or v2 \n      return Promise.resolve().then(function () {\n        return _this5.getNamePriceV2(fullyQualifiedName);\n      }).catch(function () {\n        return _this5.getNamePriceV1(fullyQualifiedName);\n      });\n    }\n    /**\r\n     * Get the price of a namespace\r\n     * @param {String} namespaceID the namespace to query\r\n     * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where\r\n     *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\r\n     *   .amount encodes the number of units, in the smallest denominiated amount\r\n     *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\r\n     *   .amount will be microStacks)\r\n     */\n\n  }, {\n    key: \"getNamespacePrice\",\n    value: function getNamespacePrice(namespaceID) {\n      var _this6 = this;\n\n      // handle v1 or v2 \n      return Promise.resolve().then(function () {\n        return _this6.getNamespacePriceV2(namespaceID);\n      }).catch(function () {\n        return _this6.getNamespacePriceV1(namespaceID);\n      });\n    }\n    /**\r\n     * How many blocks can pass between a name expiring and the name being able to be\r\n     * re-registered by a different owner?\r\n     * @param {string} fullyQualifiedName unused\r\n     * @return {Promise} a promise to the number of blocks\r\n     */\n\n  }, {\n    key: \"getGracePeriod\",\n    value: function getGracePeriod(fullyQualifiedName) {\n      return Promise.resolve(5000);\n    }\n    /**\r\n     * Get the names -- both on-chain and off-chain -- owned by an address.\r\n     * @param {String} address the blockchain address (the hash of the owner public key)\r\n     * @return {Promise} a promise that resolves to a list of names (Strings)\r\n     */\n\n  }, {\n    key: \"getNamesOwned\",\n    value: function getNamesOwned(address) {\n      var networkAddress = this.coerceAddress(address);\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/addresses/bitcoin/\").concat(networkAddress)).then(function (resp) {\n        return resp.json();\n      }).then(function (obj) {\n        return obj.names;\n      });\n    }\n    /**\r\n     * Get the blockchain address to which a name's registration fee must be sent\r\n     * (the address will depend on the namespace in which it is registered.)\r\n     * @param {String} namespace the namespace ID\r\n     * @return {Promise} a promise that resolves to an address (String)\r\n     */\n\n  }, {\n    key: \"getNamespaceBurnAddress\",\n    value: function getNamespaceBurnAddress(namespace) {\n      var _this7 = this;\n\n      return Promise.all([fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/namespaces/\").concat(namespace)), this.getBlockHeight()]).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            resp = _ref2[0],\n            blockHeight = _ref2[1];\n\n        if (resp.status === 404) {\n          throw new Error(\"No such namespace '\".concat(namespace, \"'\"));\n        } else {\n          return Promise.all([resp.json(), blockHeight]);\n        }\n      }).then(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            namespaceInfo = _ref4[0],\n            blockHeight = _ref4[1];\n\n        var address = _this7.getDefaultBurnAddress();\n\n        if (namespaceInfo.version === 2) {\n          // pay-to-namespace-creator if this namespace is less than 1 year old\n          if (namespaceInfo.reveal_block + 52595 >= blockHeight) {\n            address = namespaceInfo.address;\n          }\n        }\n\n        return address;\n      }).then(function (address) {\n        return _this7.coerceAddress(address);\n      });\n    }\n    /**\r\n     * Get WHOIS-like information for a name, including the address that owns it,\r\n     * the block at which it expires, and the zone file anchored to it (if available).\r\n     * @param {String} fullyQualifiedName the name to query.  Can be on-chain of off-chain.\r\n     * @return {Promise} a promise that resolves to the WHOIS-like information\r\n     */\n\n  }, {\n    key: \"getNameInfo\",\n    value: function getNameInfo(fullyQualifiedName) {\n      var _this8 = this;\n\n      logger_1.Logger.debug(this.blockstackAPIUrl);\n      var nameLookupURL = \"\".concat(this.blockstackAPIUrl, \"/v1/names/\").concat(fullyQualifiedName);\n      return fetch(nameLookupURL).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Name not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (nameInfo) {\n        logger_1.Logger.debug(\"nameInfo: \".concat(JSON.stringify(nameInfo))); // the returned address _should_ be in the correct network ---\n        //  blockstackd gets into trouble because it tries to coerce back to mainnet\n        //  and the regtest transaction generation libraries want to use testnet addresses\n\n        if (nameInfo.address) {\n          return Object.assign({}, nameInfo, {\n            address: _this8.coerceAddress(nameInfo.address)\n          });\n        } else {\n          return nameInfo;\n        }\n      });\n    }\n    /**\r\n     * Get the pricing parameters and creation history of a namespace.\r\n     * @param {String} namespaceID the namespace to query\r\n     * @return {Promise} a promise that resolves to the namespace information.\r\n     */\n\n  }, {\n    key: \"getNamespaceInfo\",\n    value: function getNamespaceInfo(namespaceID) {\n      var _this9 = this;\n\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/namespaces/\").concat(namespaceID)).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Namespace not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (namespaceInfo) {\n        // the returned address _should_ be in the correct network ---\n        //  blockstackd gets into trouble because it tries to coerce back to mainnet\n        //  and the regtest transaction generation libraries want to use testnet addresses\n        if (namespaceInfo.address && namespaceInfo.recipient_address) {\n          return Object.assign({}, namespaceInfo, {\n            address: _this9.coerceAddress(namespaceInfo.address),\n            recipient_address: _this9.coerceAddress(namespaceInfo.recipient_address)\n          });\n        } else {\n          return namespaceInfo;\n        }\n      });\n    }\n    /**\r\n     * Get a zone file, given its hash.  Throws an exception if the zone file\r\n     * obtained does not match the hash.\r\n     * @param {String} zonefileHash the ripemd160(sha256) hash of the zone file\r\n     * @return {Promise} a promise that resolves to the zone file's text\r\n     */\n\n  }, {\n    key: \"getZonefile\",\n    value: function getZonefile(zonefileHash) {\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/zonefiles/\").concat(zonefileHash)).then(function (resp) {\n        if (resp.status === 200) {\n          return resp.text().then(function (body) {\n            var sha256 = bitcoinjs_lib_1.default.crypto.sha256(Buffer.from(body));\n            var h = new ripemd160_1.default().update(sha256).digest('hex');\n\n            if (h !== zonefileHash) {\n              throw new Error(\"Zone file contents hash to \".concat(h, \", not \").concat(zonefileHash));\n            }\n\n            return body;\n          });\n        } else {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        }\n      });\n    }\n    /**\r\n     * Get the status of an account for a particular token holding.  This includes its total number of\r\n     * expenditures and credits, lockup times, last txid, and so on.\r\n     * @param {String} address the account\r\n     * @param {String} tokenType the token type to query\r\n     * @return {Promise} a promise that resolves to an object representing the state of the account\r\n     *   for this token\r\n     */\n\n  }, {\n    key: \"getAccountStatus\",\n    value: function getAccountStatus(address, tokenType) {\n      var _this10 = this;\n\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/\").concat(tokenType, \"/status\")).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Account not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (accountStatus) {\n        // coerce all addresses, and convert credit/debit to biginteger\n        var formattedStatus = Object.assign({}, accountStatus, {\n          address: _this10.coerceAddress(accountStatus.address),\n          debit_value: new bn_js_1.default(String(accountStatus.debit_value)),\n          credit_value: new bn_js_1.default(String(accountStatus.credit_value))\n        });\n        return formattedStatus;\n      });\n    }\n    /**\r\n     * Get a page of an account's transaction history.\r\n     * @param {String} address the account's address\r\n     * @param {number} page the page number.  Page 0 is the most recent transactions\r\n     * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes\r\n     *   states of the account at various block heights (e.g. prior balances, txids, etc)\r\n     */\n\n  }, {\n    key: \"getAccountHistoryPage\",\n    value: function getAccountHistoryPage(address, page) {\n      var _this11 = this;\n\n      var url = \"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/history?page=\").concat(page);\n      return fetch(url).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Account not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (historyList) {\n        if (historyList.error) {\n          throw new Error(\"Unable to get account history page: \".concat(historyList.error));\n        } // coerse all addresses and convert to bigint\n\n\n        return historyList.map(function (histEntry) {\n          histEntry.address = _this11.coerceAddress(histEntry.address);\n          histEntry.debit_value = new bn_js_1.default(String(histEntry.debit_value));\n          histEntry.credit_value = new bn_js_1.default(String(histEntry.credit_value));\n          return histEntry;\n        });\n      });\n    }\n    /**\r\n     * Get the state(s) of an account at a particular block height.  This includes the state of the\r\n     * account beginning with this block's transactions, as well as all of the states the account\r\n     * passed through when this block was processed (if any).\r\n     * @param {String} address the account's address\r\n     * @param {Integer} blockHeight the block to query\r\n     * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes\r\n     *   states of the account at this block.\r\n     */\n\n  }, {\n    key: \"getAccountAt\",\n    value: function getAccountAt(address, blockHeight) {\n      var _this12 = this;\n\n      var url = \"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/history/\").concat(blockHeight);\n      return fetch(url).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Account not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (historyList) {\n        if (historyList.error) {\n          throw new Error(\"Unable to get historic account state: \".concat(historyList.error));\n        } // coerce all addresses \n\n\n        return historyList.map(function (histEntry) {\n          histEntry.address = _this12.coerceAddress(histEntry.address);\n          histEntry.debit_value = new bn_js_1.default(String(histEntry.debit_value));\n          histEntry.credit_value = new bn_js_1.default(String(histEntry.credit_value));\n          return histEntry;\n        });\n      });\n    }\n    /**\r\n     * Get the set of token types that this account owns\r\n     * @param {String} address the account's address\r\n     * @return {Promise} a promise that resolves to an Array of Strings, where each item encodes the\r\n     *   type of token this account holds (excluding the underlying blockchain's tokens)\r\n     */\n\n  }, {\n    key: \"getAccountTokens\",\n    value: function getAccountTokens(address) {\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/tokens\")).then(function (resp) {\n        if (resp.status === 404) {\n          throw new Error('Account not found');\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (tokenList) {\n        if (tokenList.error) {\n          throw new Error(\"Unable to get token list: \".concat(tokenList.error));\n        }\n\n        return tokenList;\n      });\n    }\n    /**\r\n     * Get the number of tokens owned by an account.  If the account does not exist or has no\r\n     * tokens of this type, then 0 will be returned.\r\n     * @param {String} address the account's address\r\n     * @param {String} tokenType the type of token to query.\r\n     * @return {Promise} a promise that resolves to a BigInteger that encodes the number of tokens\r\n     *   held by this account.\r\n     */\n\n  }, {\n    key: \"getAccountBalance\",\n    value: function getAccountBalance(address, tokenType) {\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/\").concat(tokenType, \"/balance\")).then(function (resp) {\n        if (resp.status === 404) {\n          // talking to an older blockstack core node without the accounts API\n          return Promise.resolve().then(function () {\n            return new bn_js_1.default('0');\n          });\n        } else if (resp.status !== 200) {\n          throw new Error(\"Bad response status: \".concat(resp.status));\n        } else {\n          return resp.json();\n        }\n      }).then(function (tokenBalance) {\n        if (tokenBalance.error) {\n          throw new Error(\"Unable to get account balance: \".concat(tokenBalance.error));\n        }\n\n        var balance = '0';\n\n        if (tokenBalance && tokenBalance.balance) {\n          balance = tokenBalance.balance;\n        }\n\n        return new bn_js_1.default(balance);\n      });\n    }\n    /**\r\n     * Performs a POST request to the given URL\r\n     * @param  {String} endpoint  the name of\r\n     * @param  {String} body [description]\r\n     * @return {Promise<Object|Error>} Returns a `Promise` that resolves to the object requested.\r\n     * In the event of an error, it rejects with:\r\n     * * a `RemoteServiceError` if there is a problem\r\n     * with the transaction broadcast service\r\n     * * `MissingParameterError` if you call the function without a required\r\n     * parameter\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: \"broadcastServiceFetchHelper\",\n    value: function broadcastServiceFetchHelper(endpoint, body) {\n      var requestHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      };\n      var options = {\n        method: 'POST',\n        headers: requestHeaders,\n        body: JSON.stringify(body)\n      };\n      var url = \"\".concat(this.broadcastServiceUrl, \"/v1/broadcast/\").concat(endpoint);\n      return fetch(url, options).then(function (response) {\n        if (response.ok) {\n          return response.json();\n        } else {\n          throw new errors_1.RemoteServiceError(response);\n        }\n      });\n    }\n    /**\r\n    * Broadcasts a signed bitcoin transaction to the network optionally waiting to broadcast the\r\n    * transaction until a second transaction has a certain number of confirmations.\r\n    *\r\n    * @param  {string} transaction the hex-encoded transaction to broadcast\r\n    * @param  {string} transactionToWatch the hex transaction id of the transaction to watch for\r\n    * the specified number of confirmations before broadcasting the `transaction`\r\n    * @param  {number} confirmations the number of confirmations `transactionToWatch` must have\r\n    * before broadcasting `transaction`.\r\n    * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\r\n    * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\r\n    *\r\n    * In the event of an error, it rejects with:\r\n    * * a `RemoteServiceError` if there is a problem\r\n    *   with the transaction broadcast service\r\n    * * `MissingParameterError` if you call the function without a required\r\n    *   parameter\r\n    * @private\r\n    */\n\n  }, {\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      var transactionToWatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var confirmations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6;\n\n      if (!transaction) {\n        var error = new errors_1.MissingParameterError('transaction');\n        return Promise.reject(error);\n      }\n\n      if (!confirmations && confirmations !== 0) {\n        var _error = new errors_1.MissingParameterError('confirmations');\n\n        return Promise.reject(_error);\n      }\n\n      if (transactionToWatch === null) {\n        return this.btc.broadcastTransaction(transaction);\n      } else {\n        /*\r\n         * POST /v1/broadcast/transaction\r\n         * Request body:\r\n         * JSON.stringify({\r\n         *  transaction,\r\n         *  transactionToWatch,\r\n         *  confirmations\r\n         * })\r\n         */\n        var endpoint = TX_BROADCAST_SERVICE_TX_ENDPOINT;\n        var requestBody = {\n          transaction: transaction,\n          transactionToWatch: transactionToWatch,\n          confirmations: confirmations\n        };\n        return this.broadcastServiceFetchHelper(endpoint, requestBody);\n      }\n    }\n    /**\r\n     * Broadcasts a zone file to the Atlas network via the transaction broadcast service.\r\n     *\r\n     * @param  {String} zoneFile the zone file to be broadcast to the Atlas network\r\n     * @param  {String} transactionToWatch the hex transaction id of the transaction\r\n     * to watch for confirmation before broadcasting the zone file to the Atlas network\r\n     * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\r\n     * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\r\n     *\r\n     * In the event of an error, it rejects with:\r\n     * * a `RemoteServiceError` if there is a problem\r\n     *   with the transaction broadcast service\r\n     * * `MissingParameterError` if you call the function without a required\r\n     *   parameter\r\n     * @private\r\n     */\n\n  }, {\n    key: \"broadcastZoneFile\",\n    value: function broadcastZoneFile(zoneFile) {\n      var transactionToWatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!zoneFile) {\n        return Promise.reject(new errors_1.MissingParameterError('zoneFile'));\n      } // TODO: validate zonefile\n\n\n      if (transactionToWatch) {\n        // broadcast via transaction broadcast service\n\n        /*\r\n         * POST /v1/broadcast/zone-file\r\n         * Request body:\r\n         * JSON.stringify({\r\n         *  zoneFile,\r\n         *  transactionToWatch\r\n         * })\r\n         */\n        var requestBody = {\n          zoneFile: zoneFile,\n          transactionToWatch: transactionToWatch\n        };\n        var endpoint = TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT;\n        return this.broadcastServiceFetchHelper(endpoint, requestBody);\n      } else {\n        // broadcast via core endpoint\n        // zone file is two words but core's api treats it as one word 'zonefile'\n        var _requestBody = {\n          zonefile: zoneFile\n        };\n        return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/zonefile/\"), {\n          method: 'POST',\n          body: JSON.stringify(_requestBody),\n          headers: {\n            'Content-Type': 'application/json'\n          }\n        }).then(function (resp) {\n          var json = resp.json();\n          return json.then(function (respObj) {\n            if (respObj.hasOwnProperty('error')) {\n              throw new errors_1.RemoteServiceError(resp);\n            }\n\n            return respObj.servers;\n          });\n        });\n      }\n    }\n    /**\r\n     * Sends the preorder and registration transactions and zone file\r\n     * for a Blockstack name registration\r\n     * along with the to the transaction broadcast service.\r\n     *\r\n     * The transaction broadcast:\r\n     *\r\n     * * immediately broadcasts the preorder transaction\r\n     * * broadcasts the register transactions after the preorder transaction\r\n     * has an appropriate number of confirmations\r\n     * * broadcasts the zone file to the Atlas network after the register transaction\r\n     * has an appropriate number of confirmations\r\n     *\r\n     * @param  {String} preorderTransaction the hex-encoded, signed preorder transaction generated\r\n     * using the `makePreorder` function\r\n     * @param  {String} registerTransaction the hex-encoded, signed register transaction generated\r\n     * using the `makeRegister` function\r\n     * @param  {String} zoneFile the zone file to be broadcast to the Atlas network\r\n     * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\r\n     * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\r\n     *\r\n     * In the event of an error, it rejects with:\r\n     * * a `RemoteServiceError` if there is a problem\r\n     *   with the transaction broadcast service\r\n     * * `MissingParameterError` if you call the function without a required\r\n     *   parameter\r\n     * @private\r\n     */\n\n  }, {\n    key: \"broadcastNameRegistration\",\n    value: function broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile) {\n      /*\r\n         * POST /v1/broadcast/registration\r\n         * Request body:\r\n         * JSON.stringify({\r\n         * preorderTransaction,\r\n         * registerTransaction,\r\n         * zoneFile\r\n         * })\r\n         */\n      if (!preorderTransaction) {\n        var error = new errors_1.MissingParameterError('preorderTransaction');\n        return Promise.reject(error);\n      }\n\n      if (!registerTransaction) {\n        var _error2 = new errors_1.MissingParameterError('registerTransaction');\n\n        return Promise.reject(_error2);\n      }\n\n      if (!zoneFile) {\n        var _error3 = new errors_1.MissingParameterError('zoneFile');\n\n        return Promise.reject(_error3);\n      }\n\n      var requestBody = {\n        preorderTransaction: preorderTransaction,\n        registerTransaction: registerTransaction,\n        zoneFile: zoneFile\n      };\n      var endpoint = TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT;\n      return this.broadcastServiceFetchHelper(endpoint, requestBody);\n    }\n  }, {\n    key: \"getFeeRate\",\n    value: function getFeeRate() {\n      return fetch('https://bitcoinfees.earn.com/api/v1/fees/recommended').then(function (resp) {\n        return resp.json();\n      }).then(function (rates) {\n        return Math.floor(rates.fastestFee);\n      });\n    }\n  }, {\n    key: \"countDustOutputs\",\n    value: function countDustOutputs() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"getUTXOs\",\n    value: function getUTXOs(address) {\n      var _this13 = this;\n\n      return this.getNetworkedUTXOs(address).then(function (networkedUTXOs) {\n        var returnSet = networkedUTXOs.concat();\n\n        if (_this13.includeUtxoMap.hasOwnProperty(address)) {\n          returnSet = networkedUTXOs.concat(_this13.includeUtxoMap[address]);\n        } // aaron: I am *well* aware this is O(n)*O(m) runtime\n        //    however, clients should clear the exclude set periodically\n\n\n        var excludeSet = _this13.excludeUtxoSet;\n        returnSet = returnSet.filter(function (utxo) {\n          var inExcludeSet = excludeSet.reduce(function (inSet, utxoToCheck) {\n            return inSet || utxoToCheck.tx_hash === utxo.tx_hash && utxoToCheck.tx_output_n === utxo.tx_output_n;\n          }, false);\n          return !inExcludeSet;\n        });\n        return returnSet;\n      });\n    }\n    /**\r\n     * This will modify the network's utxo set to include UTXOs\r\n     *  from the given transaction and exclude UTXOs *spent* in\r\n     *  that transaction\r\n     * @param {String} txHex - the hex-encoded transaction to use\r\n     * @return {void} no return value, this modifies the UTXO config state\r\n     * @private\r\n     */\n\n  }, {\n    key: \"modifyUTXOSetFrom\",\n    value: function modifyUTXOSetFrom(txHex) {\n      var _this14 = this;\n\n      var tx = bitcoinjs_lib_1.default.Transaction.fromHex(txHex);\n      var excludeSet = this.excludeUtxoSet.concat();\n      tx.ins.forEach(function (utxoUsed) {\n        var reverseHash = Buffer.from(utxoUsed.hash);\n        reverseHash.reverse();\n        excludeSet.push({\n          tx_hash: reverseHash.toString('hex'),\n          tx_output_n: utxoUsed.index\n        });\n      });\n      this.excludeUtxoSet = excludeSet;\n      var txHash = Buffer.from(tx.getHash().reverse()).toString('hex');\n      tx.outs.forEach(function (utxoCreated, txOutputN) {\n        var isNullData = function isNullData(script) {\n          try {\n            bitcoinjs_lib_1.default.payments.embed({\n              output: script\n            }, {\n              validate: true\n            });\n            return true;\n          } catch (_) {\n            return false;\n          }\n        };\n\n        if (isNullData(utxoCreated.script)) {\n          return;\n        }\n\n        var address = bitcoinjs_lib_1.default.address.fromOutputScript(utxoCreated.script, _this14.layer1);\n        var includeSet = [];\n\n        if (_this14.includeUtxoMap.hasOwnProperty(address)) {\n          includeSet = includeSet.concat(_this14.includeUtxoMap[address]);\n        }\n\n        includeSet.push({\n          tx_hash: txHash,\n          confirmations: 0,\n          value: utxoCreated.value,\n          tx_output_n: txOutputN\n        });\n        _this14.includeUtxoMap[address] = includeSet;\n      });\n    }\n  }, {\n    key: \"resetUTXOs\",\n    value: function resetUTXOs(address) {\n      delete this.includeUtxoMap[address];\n      this.excludeUtxoSet = [];\n    }\n  }, {\n    key: \"getConsensusHash\",\n    value: function getConsensusHash() {\n      return fetch(\"\".concat(this.blockstackAPIUrl, \"/v1/blockchains/bitcoin/consensus\")).then(function (resp) {\n        return resp.json();\n      }).then(function (x) {\n        return x.consensus_hash;\n      });\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txHash) {\n      return this.btc.getTransactionInfo(txHash);\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      return this.btc.getBlockHeight();\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      return this.btc.getNetworkedUTXOs(address);\n    }\n  }]);\n\n  return BlockstackNetwork;\n}();\n\nexports.BlockstackNetwork = BlockstackNetwork;\n\nvar LocalRegtest =\n/*#__PURE__*/\nfunction (_BlockstackNetwork) {\n  _inherits(LocalRegtest, _BlockstackNetwork);\n\n  function LocalRegtest(apiUrl, broadcastServiceUrl, bitcoinAPI) {\n    _classCallCheck(this, LocalRegtest);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LocalRegtest).call(this, apiUrl, broadcastServiceUrl, bitcoinAPI, bitcoinjs_lib_1.default.networks.testnet));\n  }\n\n  _createClass(LocalRegtest, [{\n    key: \"getFeeRate\",\n    value: function getFeeRate() {\n      return Promise.resolve(Math.floor(0.00001000 * SATOSHIS_PER_BTC));\n    }\n  }]);\n\n  return LocalRegtest;\n}(BlockstackNetwork);\n\nexports.LocalRegtest = LocalRegtest;\n\nvar BitcoindAPI =\n/*#__PURE__*/\nfunction (_BitcoinNetwork) {\n  _inherits(BitcoindAPI, _BitcoinNetwork);\n\n  function BitcoindAPI(bitcoindUrl, bitcoindCredentials) {\n    var _this15;\n\n    _classCallCheck(this, BitcoindAPI);\n\n    _this15 = _possibleConstructorReturn(this, _getPrototypeOf(BitcoindAPI).call(this));\n    _this15.bitcoindUrl = bitcoindUrl;\n    _this15.bitcoindCredentials = bitcoindCredentials;\n    _this15.importedBefore = {};\n    return _this15;\n  }\n\n  _createClass(BitcoindAPI, [{\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      var jsonRPC = {\n        jsonrpc: '1.0',\n        method: 'sendrawtransaction',\n        params: [transaction]\n      };\n      var authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n      var headers = {\n        Authorization: \"Basic \".concat(authString)\n      };\n      return fetch(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPC),\n        headers: headers\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (respObj) {\n        return respObj.result;\n      });\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      var jsonRPC = {\n        jsonrpc: '1.0',\n        method: 'getblockcount'\n      };\n      var authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n      var headers = {\n        Authorization: \"Basic \".concat(authString)\n      };\n      return fetch(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPC),\n        headers: headers\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (respObj) {\n        return respObj.result;\n      });\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txHash) {\n      var _this16 = this;\n\n      var jsonRPC = {\n        jsonrpc: '1.0',\n        method: 'gettransaction',\n        params: [txHash]\n      };\n      var authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n      var headers = {\n        Authorization: \"Basic \".concat(authString)\n      };\n      return fetch(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPC),\n        headers: headers\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (respObj) {\n        return respObj.result;\n      }).then(function (txInfo) {\n        return txInfo.blockhash;\n      }).then(function (blockhash) {\n        var jsonRPCBlock = {\n          jsonrpc: '1.0',\n          method: 'getblockheader',\n          params: [blockhash]\n        };\n        headers.Authorization = \"Basic \".concat(authString);\n        return fetch(_this16.bitcoindUrl, {\n          method: 'POST',\n          body: JSON.stringify(jsonRPCBlock),\n          headers: headers\n        });\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (respObj) {\n        if (!respObj || !respObj.result) {\n          // unconfirmed \n          throw new Error('Unconfirmed transaction');\n        } else {\n          return {\n            block_height: respObj.result.height\n          };\n        }\n      });\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      var _this17 = this;\n\n      var jsonRPCImport = {\n        jsonrpc: '1.0',\n        method: 'importaddress',\n        params: [address]\n      };\n      var jsonRPCUnspent = {\n        jsonrpc: '1.0',\n        method: 'listunspent',\n        params: [0, 9999999, [address]]\n      };\n      var authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n      var headers = {\n        Authorization: \"Basic \".concat(authString)\n      };\n      var importPromise = this.importedBefore[address] ? Promise.resolve() : fetch(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPCImport),\n        headers: headers\n      }).then(function () {\n        _this17.importedBefore[address] = true;\n      });\n      return importPromise.then(function () {\n        return fetch(_this17.bitcoindUrl, {\n          method: 'POST',\n          body: JSON.stringify(jsonRPCUnspent),\n          headers: headers\n        });\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (x) {\n        return x.result;\n      }).then(function (utxos) {\n        return utxos.map(function (x) {\n          return {\n            value: Math.round(x.amount * SATOSHIS_PER_BTC),\n            confirmations: x.confirmations,\n            tx_hash: x.txid,\n            tx_output_n: x.vout\n          };\n        });\n      });\n    }\n  }]);\n\n  return BitcoindAPI;\n}(BitcoinNetwork);\n\nexports.BitcoindAPI = BitcoindAPI;\n\nvar InsightClient =\n/*#__PURE__*/\nfunction (_BitcoinNetwork2) {\n  _inherits(InsightClient, _BitcoinNetwork2);\n\n  function InsightClient() {\n    var _this18;\n\n    var insightUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'https://utxo.technofractal.com/';\n\n    _classCallCheck(this, InsightClient);\n\n    _this18 = _possibleConstructorReturn(this, _getPrototypeOf(InsightClient).call(this));\n    _this18.apiUrl = insightUrl;\n    return _this18;\n  }\n\n  _createClass(InsightClient, [{\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      var jsonData = {\n        rawtx: transaction\n      };\n      return fetch(\"\".concat(this.apiUrl, \"/tx/send\"), {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(jsonData)\n      }).then(function (resp) {\n        return resp.json();\n      });\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      return fetch(\"\".concat(this.apiUrl, \"/status\")).then(function (resp) {\n        return resp.json();\n      }).then(function (status) {\n        return status.blocks;\n      });\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txHash) {\n      var _this19 = this;\n\n      return fetch(\"\".concat(this.apiUrl, \"/tx/\").concat(txHash)).then(function (resp) {\n        return resp.json();\n      }).then(function (transactionInfo) {\n        if (transactionInfo.error) {\n          throw new Error(\"Error finding transaction: \".concat(transactionInfo.error));\n        }\n\n        return fetch(\"\".concat(_this19.apiUrl, \"/block/\").concat(transactionInfo.blockHash));\n      }).then(function (resp) {\n        return resp.json();\n      }).then(function (blockInfo) {\n        return {\n          block_height: blockInfo.height\n        };\n      });\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      return fetch(\"\".concat(this.apiUrl, \"/addr/\").concat(address, \"/utxo\")).then(function (resp) {\n        return resp.json();\n      }).then(function (utxos) {\n        return utxos.map(function (x) {\n          return {\n            value: x.satoshis,\n            confirmations: x.confirmations,\n            tx_hash: x.txid,\n            tx_output_n: x.vout\n          };\n        });\n      });\n    }\n  }]);\n\n  return InsightClient;\n}(BitcoinNetwork);\n\nexports.InsightClient = InsightClient;\n\nvar BlockchainInfoApi =\n/*#__PURE__*/\nfunction (_BitcoinNetwork3) {\n  _inherits(BlockchainInfoApi, _BitcoinNetwork3);\n\n  function BlockchainInfoApi() {\n    var _this20;\n\n    var blockchainInfoUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'https://blockchain.info';\n\n    _classCallCheck(this, BlockchainInfoApi);\n\n    _this20 = _possibleConstructorReturn(this, _getPrototypeOf(BlockchainInfoApi).call(this));\n    _this20.utxoProviderUrl = blockchainInfoUrl;\n    return _this20;\n  }\n\n  _createClass(BlockchainInfoApi, [{\n    key: \"getBlockHeight\",\n    value: function getBlockHeight() {\n      return fetch(\"\".concat(this.utxoProviderUrl, \"/latestblock?cors=true\")).then(function (resp) {\n        return resp.json();\n      }).then(function (blockObj) {\n        return blockObj.height;\n      });\n    }\n  }, {\n    key: \"getNetworkedUTXOs\",\n    value: function getNetworkedUTXOs(address) {\n      return fetch(\"\".concat(this.utxoProviderUrl, \"/unspent?format=json&active=\").concat(address, \"&cors=true\")).then(function (resp) {\n        if (resp.status === 500) {\n          logger_1.Logger.debug('UTXO provider 500 usually means no UTXOs: returning []');\n          return {\n            unspent_outputs: []\n          };\n        } else {\n          return resp.json();\n        }\n      }).then(function (utxoJSON) {\n        return utxoJSON.unspent_outputs;\n      }).then(function (utxoList) {\n        return utxoList.map(function (utxo) {\n          var utxoOut = {\n            value: utxo.value,\n            tx_output_n: utxo.tx_output_n,\n            confirmations: utxo.confirmations,\n            tx_hash: utxo.tx_hash_big_endian\n          };\n          return utxoOut;\n        });\n      });\n    }\n  }, {\n    key: \"getTransactionInfo\",\n    value: function getTransactionInfo(txHash) {\n      return fetch(\"\".concat(this.utxoProviderUrl, \"/rawtx/\").concat(txHash, \"?cors=true\")).then(function (resp) {\n        if (resp.status === 200) {\n          return resp.json();\n        } else {\n          throw new Error(\"Could not lookup transaction info for '\".concat(txHash, \"'. Server error.\"));\n        }\n      }).then(function (respObj) {\n        return {\n          block_height: respObj.block_height\n        };\n      });\n    }\n  }, {\n    key: \"broadcastTransaction\",\n    value: function broadcastTransaction(transaction) {\n      var form = new form_data_1.default();\n      form.append('tx', transaction);\n      return fetch(\"\".concat(this.utxoProviderUrl, \"/pushtx?cors=true\"), {\n        method: 'POST',\n        body: form\n      }).then(function (resp) {\n        var text = resp.text();\n        return text.then(function (respText) {\n          if (respText.toLowerCase().indexOf('transaction submitted') >= 0) {\n            var txHash = Buffer.from(bitcoinjs_lib_1.default.Transaction.fromHex(transaction).getHash().reverse()).toString('hex'); // big_endian\n\n            return txHash;\n          } else {\n            throw new errors_1.RemoteServiceError(resp, \"Broadcast transaction failed with message: \".concat(respText));\n          }\n        });\n      });\n    }\n  }]);\n\n  return BlockchainInfoApi;\n}(BitcoinNetwork);\n\nexports.BlockchainInfoApi = BlockchainInfoApi;\nvar LOCAL_REGTEST = new LocalRegtest('http://localhost:16268', 'http://localhost:16269', new BitcoindAPI('http://localhost:18332/', {\n  username: 'blockstack',\n  password: 'blockstacksystem'\n}));\nvar MAINNET_DEFAULT = new BlockstackNetwork('https://core.blockstack.org', 'https://broadcast.blockstack.org', new BlockchainInfoApi());\nexports.network = {\n  BlockstackNetwork: BlockstackNetwork,\n  LocalRegtest: LocalRegtest,\n  BlockchainInfoApi: BlockchainInfoApi,\n  BitcoindAPI: BitcoindAPI,\n  InsightClient: InsightClient,\n  defaults: {\n    LOCAL_REGTEST: LOCAL_REGTEST,\n    MAINNET_DEFAULT: MAINNET_DEFAULT\n  }\n};","map":null,"metadata":{},"sourceType":"script"}