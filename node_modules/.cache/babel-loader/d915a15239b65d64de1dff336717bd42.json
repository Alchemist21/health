{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"cross-fetch/polyfill\");\n\nvar serviceUtils_1 = require(\"./serviceUtils\");\n\nvar Service =\n/*#__PURE__*/\nfunction () {\n  function Service() {\n    _classCallCheck(this, Service);\n  }\n\n  _createClass(Service, null, [{\n    key: \"validateProof\",\n    value: function validateProof(proof, ownerAddress) {\n      var _this = this;\n\n      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var proofUrl;\n      return Promise.resolve().then(function () {\n        proofUrl = _this.getProofUrl(proof);\n        return fetch(proofUrl);\n      }).then(function (res) {\n        if (res.status !== 200) {\n          throw new Error(\"Proof url \".concat(proofUrl, \" returned unexpected http status \").concat(res.status, \".\\n              Unable to validate proof.\"));\n        }\n\n        return res.text();\n      }).then(function (text) {\n        // Validate identity in provided proof body/tags if required\n        if (_this.shouldValidateIdentityInBody() && proof.identifier !== _this.getProofIdentity(text)) {\n          return proof;\n        }\n\n        var proofText = _this.getProofStatement(text);\n\n        proof.valid = serviceUtils_1.containsValidProofStatement(proofText, name) || serviceUtils_1.containsValidAddressProofStatement(proofText, ownerAddress);\n        return proof;\n      }).catch(function (error) {\n        console.error(error);\n        proof.valid = false;\n        return proof;\n      });\n    }\n  }, {\n    key: \"getBaseUrls\",\n    value: function getBaseUrls() {\n      return [];\n    }\n  }, {\n    key: \"getProofIdentity\",\n    value: function getProofIdentity(searchText) {\n      return searchText;\n    }\n  }, {\n    key: \"getProofStatement\",\n    value: function getProofStatement(searchText) {\n      return searchText;\n    }\n  }, {\n    key: \"shouldValidateIdentityInBody\",\n    value: function shouldValidateIdentityInBody() {\n      return false;\n    }\n  }, {\n    key: \"prefixScheme\",\n    value: function prefixScheme(proofUrl) {\n      if (!proofUrl.startsWith('https://') && !proofUrl.startsWith('http://')) {\n        return \"https://\".concat(proofUrl);\n      } else if (proofUrl.startsWith('http://')) {\n        return proofUrl.replace('http://', 'https://');\n      } else {\n        return proofUrl;\n      }\n    }\n  }, {\n    key: \"getProofUrl\",\n    value: function getProofUrl(proof) {\n      var baseUrls = this.getBaseUrls();\n      var proofUrl = proof.proof_url.toLowerCase();\n      proofUrl = this.prefixScheme(proofUrl);\n\n      for (var i = 0; i < baseUrls.length; i++) {\n        var requiredPrefix = \"\".concat(baseUrls[i]).concat(proof.identifier).toLowerCase();\n\n        if (proofUrl.startsWith(requiredPrefix)) {\n          return proofUrl;\n        }\n      }\n\n      throw new Error(\"Proof url \".concat(proof.proof_url, \" is not valid for service \").concat(proof.service));\n    }\n  }]);\n\n  return Service;\n}();\n\nexports.Service = Service;","map":null,"metadata":{},"sourceType":"script"}