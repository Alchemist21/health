{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bitcoinjs_lib_1 = require(\"bitcoinjs-lib\"); // @ts-ignore: Could not find a declaration file for module\n\n\nvar jsontokens_1 = require(\"jsontokens\");\n\nvar utils_1 = require(\"../utils\");\n/**\r\n  * Signs a profile token\r\n  * @param {Object} profile - the JSON of the profile to be signed\r\n  * @param {String} privateKey - the signing private key\r\n  * @param {Object} subject - the entity that the information is about\r\n  * @param {Object} issuer - the entity that is issuing the token\r\n  * @param {String} signingAlgorithm - the signing algorithm to use\r\n  * @param {Date} issuedAt - the time of issuance of the token\r\n  * @param {Date} expiresAt - the time of expiration of the token\r\n  * @returns {Object} - the signed profile token\r\n  */\n\n\nfunction signProfileToken(profile, privateKey, subject, issuer) {\n  var signingAlgorithm = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'ES256K';\n  var issuedAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Date();\n  var expiresAt = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : utils_1.nextYear();\n\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  var publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n\n  if (!subject) {\n    subject = {\n      publicKey: publicKey\n    };\n  }\n\n  if (!issuer) {\n    issuer = {\n      publicKey: publicKey\n    };\n  }\n\n  var tokenSigner = new jsontokens_1.TokenSigner(signingAlgorithm, privateKey);\n  var payload = {\n    jti: utils_1.makeUUID4(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject: subject,\n    issuer: issuer,\n    claim: profile\n  };\n  return tokenSigner.sign(payload);\n}\n\nexports.signProfileToken = signProfileToken;\n/**\r\n  * Wraps a token for a profile token file\r\n  * @param {String} token - the token to be wrapped\r\n  * @returns {Object} - including `token` and `decodedToken`\r\n  */\n\nfunction wrapProfileToken(token) {\n  return {\n    token: token,\n    decodedToken: jsontokens_1.decodeToken(token)\n  };\n}\n\nexports.wrapProfileToken = wrapProfileToken;\n/**\r\n  * Verifies a profile token\r\n  * @param {String} token - the token to be verified\r\n  * @param {String} publicKeyOrAddress - the public key or address of the\r\n  *   keypair that is thought to have signed the token\r\n  * @returns {Object} - the verified, decoded profile token\r\n  * @throws {Error} - throws an error if token verification fails\r\n  */\n\nfunction verifyProfileToken(token, publicKeyOrAddress) {\n  var decodedToken = jsontokens_1.decodeToken(token);\n  var payload = decodedToken.payload; // Inspect and verify the subject\n\n  if (payload.hasOwnProperty('subject')) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have a subject public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have a subject');\n  } // Inspect and verify the issuer\n\n\n  if (payload.hasOwnProperty('issuer')) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have an issuer public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have an issuer');\n  } // Inspect and verify the claim\n\n\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error('Token doesn\\'t have a claim');\n  }\n\n  var issuerPublicKey = payload.issuer.publicKey;\n  var publicKeyBuffer = Buffer.from(issuerPublicKey, 'hex');\n  var compressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, {\n    compressed: true\n  });\n  var compressedAddress = utils_1.ecPairToAddress(compressedKeyPair);\n  var uncompressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, {\n    compressed: false\n  });\n  var uncompressedAddress = utils_1.ecPairToAddress(uncompressedKeyPair);\n\n  if (publicKeyOrAddress === issuerPublicKey) {// pass\n  } else if (publicKeyOrAddress === compressedAddress) {// pass\n  } else if (publicKeyOrAddress === uncompressedAddress) {// pass\n  } else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  var tokenVerifier = new jsontokens_1.TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  var tokenVerified = tokenVerifier.verify(token);\n\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\n\nexports.verifyProfileToken = verifyProfileToken;\n/**\r\n  * Extracts a profile from an encoded token and optionally verifies it,\r\n  * if `publicKeyOrAddress` is provided.\r\n  * @param {String} token - the token to be extracted\r\n  * @param {String} publicKeyOrAddress - the public key or address of the\r\n  *   keypair that is thought to have signed the token\r\n  * @returns {Object} - the profile extracted from the encoded token\r\n  * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\r\n  */\n\nfunction extractProfile(token) {\n  var publicKeyOrAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var decodedToken;\n\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = jsontokens_1.decodeToken(token);\n  }\n\n  var profile = {};\n\n  if (decodedToken.hasOwnProperty('payload')) {\n    var payload = decodedToken.payload;\n\n    if (payload.hasOwnProperty('claim')) {\n      profile = decodedToken.payload.claim;\n    }\n  }\n\n  return profile;\n}\n\nexports.extractProfile = extractProfile;","map":null,"metadata":{},"sourceType":"script"}