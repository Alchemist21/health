{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @ts-ignore: Could not find a declaration file for module\n\nvar jsontokens_1 = require(\"jsontokens\");\n\nvar dids_1 = require(\"../dids\");\n\nvar keys_1 = require(\"../keys\");\n\nvar utils_1 = require(\"../utils\");\n\nvar authProvider_1 = require(\"./authProvider\");\n/**\r\n * Checks if the ES256k signature on passed `token` match the claimed public key\r\n * in the payload key `public_keys`.\r\n *\r\n * @param  {String} token encoded and signed authentication token\r\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\r\n * @throws {Error} if `token` contains multiple public keys\r\n * @private\r\n */\n\n\nfunction doSignaturesMatchPublicKeys(token) {\n  var payload = jsontokens_1.decodeToken(token).payload;\n  var publicKeys = payload.public_keys;\n\n  if (publicKeys.length === 1) {\n    var publicKey = publicKeys[0];\n\n    try {\n      var tokenVerifier = new jsontokens_1.TokenVerifier('ES256k', publicKey);\n      var signatureVerified = tokenVerifier.verify(token);\n\n      if (signatureVerified) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n\nexports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;\n/**\r\n * Makes sure that the identity address portion of\r\n * the decentralized identifier passed in the issuer `iss`\r\n * key of the token matches the public key\r\n *\r\n * @param  {String} token encoded and signed authentication token\r\n * @return {Boolean} if the identity address and public keys match\r\n * @throws {Error} if ` token` has multiple public keys\r\n * @private\r\n */\n\nfunction doPublicKeysMatchIssuer(token) {\n  var payload = jsontokens_1.decodeToken(token).payload;\n  var publicKeys = payload.public_keys;\n  var addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    var addressFromPublicKeys = keys_1.publicKeyToAddress(publicKeys[0]);\n\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n\nexports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;\n/**\r\n * Looks up the identity address that owns the claimed username\r\n * in `token` using the lookup endpoint provided in `nameLookupURL`\r\n * to determine if the username is owned by the identity address\r\n * that matches the claimed public key\r\n *\r\n * @param  {String} token  encoded and signed authentication token\r\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\r\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\r\n * `true` if the username is owned by the public key, otherwise the\r\n * `Promise` resolves to `false`\r\n * @private\r\n */\n\nfunction doPublicKeysMatchUsername(token, nameLookupURL) {\n  return Promise.resolve().then(function () {\n    var payload = jsontokens_1.decodeToken(token).payload;\n\n    if (!payload.username) {\n      return true;\n    }\n\n    if (payload.username === null) {\n      return true;\n    }\n\n    if (nameLookupURL === null) {\n      return false;\n    }\n\n    var username = payload.username;\n    var url = \"\".concat(nameLookupURL.replace(/\\/$/, ''), \"/\").concat(username);\n    return fetch(url).then(function (response) {\n      return response.text();\n    }).then(function (responseText) {\n      var responseJSON = JSON.parse(responseText);\n\n      if (responseJSON.hasOwnProperty('address')) {\n        var nameOwningAddress = responseJSON.address;\n        var addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n\n        if (nameOwningAddress === addressFromIssuer) {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    });\n  }).catch(function () {\n    return false;\n  });\n}\n\nexports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;\n/**\r\n * Checks if the if the token issuance time and date is after the\r\n * current time and date.\r\n *\r\n * @param  {String}  token encoded and signed authentication token\r\n * @return {Boolean} `true` if the token was issued after the current time,\r\n * otherwise returns `false`\r\n * @private\r\n */\n\nfunction isIssuanceDateValid(token) {\n  var payload = jsontokens_1.decodeToken(token).payload;\n\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n\n    var issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\nexports.isIssuanceDateValid = isIssuanceDateValid;\n/**\r\n * Checks if the expiration date of the `token` is before the current time\r\n * @param  {String}  token encoded and signed authentication token\r\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\r\n * if the `token` has expired\r\n *\r\n * @private\r\n */\n\nfunction isExpirationDateValid(token) {\n  var payload = jsontokens_1.decodeToken(token).payload;\n\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n\n    var expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\nexports.isExpirationDateValid = isExpirationDateValid;\n/**\r\n * Makes sure the `manifest_uri` is a same origin absolute URL.\r\n * @param  {String}  token encoded and signed authentication token\r\n * @return {Boolean} `true` if valid, otherwise `false`\r\n * @private\r\n */\n\nfunction isManifestUriValid(token) {\n  var payload = jsontokens_1.decodeToken(token).payload;\n  return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\n\nexports.isManifestUriValid = isManifestUriValid;\n/**\r\n * Makes sure the `redirect_uri` is a same origin absolute URL.\r\n * @param  {String}  token encoded and signed authentication token\r\n * @return {Boolean} `true` if valid, otherwise `false`\r\n * @private\r\n */\n\nfunction isRedirectUriValid(token) {\n  var payload = jsontokens_1.decodeToken(token).payload;\n  return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\n\nexports.isRedirectUriValid = isRedirectUriValid;\n/**\r\n * Verify authentication request is valid. This function performs a number\r\n * of checks on the authentication request token:\r\n * * Checks that `token` has a valid issuance date & is not expired\r\n * * Checks that `token` has a valid signature that matches the public key it claims\r\n * * Checks that both the manifest and redirect URLs are absolute and conform to\r\n * the same origin policy\r\n *\r\n * @param  {String} token encoded and signed authentication request token\r\n * @return {Promise} that resolves to true if the auth request\r\n *  is valid and false if it does not. It rejects with a String if the\r\n *  token is not signed\r\n *  @private\r\n */\n\nfunction verifyAuthRequest(token) {\n  return Promise.resolve().then(function () {\n    if (jsontokens_1.decodeToken(token).header.alg === 'none') {\n      throw new Error('Token must be signed in order to be verified');\n    }\n  }).then(function () {\n    return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]);\n  }).then(function (values) {\n    if (values.every(Boolean)) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexports.verifyAuthRequest = verifyAuthRequest;\n/**\r\n * Verify the authentication request is valid and\r\n * fetch the app manifest file if valid. Otherwise, reject the promise.\r\n * @param  {String} token encoded and signed authentication request token\r\n * @return {Promise} that resolves to the app manifest file in JSON format\r\n * or rejects if the auth request or app manifest file is invalid\r\n * @private\r\n */\n\nfunction verifyAuthRequestAndLoadManifest(token) {\n  return Promise.resolve().then(function () {\n    return verifyAuthRequest(token).then(function (valid) {\n      if (valid) {\n        return authProvider_1.fetchAppManifest(token);\n      } else {\n        return Promise.reject();\n      }\n    });\n  });\n}\n\nexports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;\n/**\r\n * Verify the authentication response is valid\r\n * @param {String} token the authentication response token\r\n * @param {String} nameLookupURL the url use to verify owner of a username\r\n * @return {Promise} that resolves to true if auth response\r\n * is valid and false if it does not\r\n * @private\r\n */\n\nfunction verifyAuthResponse(token, nameLookupURL) {\n  return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), doPublicKeysMatchUsername(token, nameLookupURL)]).then(function (values) {\n    if (values.every(Boolean)) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexports.verifyAuthResponse = verifyAuthResponse;","map":null,"metadata":{},"sourceType":"script"}