{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"cross-fetch/polyfill\"); // @ts-ignore: Could not find a declaration file for module\n\n\nvar jsontokens_1 = require(\"jsontokens\");\n\nvar keys_1 = require(\"../keys\");\n\nvar utils_1 = require(\"../utils\");\n\nvar dids_1 = require(\"../dids\");\n\nvar ec_1 = require(\"../encryption/ec\");\n\nvar logger_1 = require(\"../logger\");\n\nvar authConstants_1 = require(\"./authConstants\");\n\nvar userSession_1 = require(\"./userSession\");\n\nvar VERSION = '1.3.1';\n/**\r\n * Generates a ECDSA keypair to\r\n * use as the ephemeral app transit private key\r\n * @param {SessionData} session - session object in which key will be stored\r\n * @return {String} the hex encoded private key\r\n * @private\r\n */\n\nfunction generateTransitKey() {\n  var transitKey = keys_1.makeECPrivateKey();\n  return transitKey;\n}\n\nexports.generateTransitKey = generateTransitKey;\n/**\r\n * Generates an authentication request that can be sent to the Blockstack\r\n * browser for the user to approve sign in. This authentication request can\r\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\r\n * method.\r\n *\r\n * *Note: This method should only be used if you want to roll your own authentication\r\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\r\n * under the hood.*\r\n *\r\n * @param  {String} transitPrivateKey - hex encoded transit private key\r\n * @param {String} redirectURI - location to redirect user to after sign in approval\r\n * @param {String} manifestURI - location of this app's manifest file\r\n * @param {Array<String>} scopes - the permissions this app is requesting\r\n * @param {String} appDomain - the origin of this app\r\n * @param {Number} expiresAt - the time at which this request is no longer valid\r\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\r\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\r\n * by special authenticators.\r\n * @return {String} the authentication request\r\n */\n\nfunction makeAuthRequest(transitPrivateKey, redirectURI, manifestURI) {\n  var scopes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : authConstants_1.DEFAULT_SCOPE;\n  var appDomain = arguments.length > 4 ? arguments[4] : undefined;\n  var expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : utils_1.nextMonth().getTime();\n  var extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n  if (!transitPrivateKey) {\n    transitPrivateKey = new userSession_1.UserSession().generateAndStoreTransitKey();\n  }\n\n  var getWindowOrigin = function getWindowOrigin(paramName) {\n    var origin = typeof window !== 'undefined' && window.location && window.location.origin;\n\n    if (!origin) {\n      var errMsg = \"`makeAuthRequest` called without the `\".concat(paramName, \"` param specified but\") + ' the default value uses `window.location.origin` which is not available in this environment';\n      logger_1.Logger.error(errMsg);\n      throw new Error(errMsg);\n    }\n\n    return origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = \"\".concat(getWindowOrigin('redirectURI'), \"/\");\n  }\n\n  if (!manifestURI) {\n    manifestURI = \"\".concat(getWindowOrigin('manifestURI'), \"/manifest.json\");\n  }\n\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n  /* Create the payload */\n\n\n  var payload = Object.assign({}, extraParams, {\n    jti: utils_1.makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes: scopes\n  });\n  logger_1.Logger.info(\"blockstack.js: generating v\".concat(VERSION, \" auth request\"));\n  /* Convert the private key to a public key to an issuer */\n\n  var publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  var address = keys_1.publicKeyToAddress(publicKey);\n  payload.iss = dids_1.makeDIDFromAddress(address);\n  /* Sign and return the token */\n\n  var tokenSigner = new jsontokens_1.TokenSigner('ES256k', transitPrivateKey);\n  var token = tokenSigner.sign(payload);\n  return token;\n}\n\nexports.makeAuthRequest = makeAuthRequest;\n/**\r\n * Encrypts the private key for decryption by the given\r\n * public key.\r\n * @param  {String} publicKey  [description]\r\n * @param  {String} privateKey [description]\r\n * @return {String} hex encoded ciphertext\r\n * @private\r\n */\n\nfunction encryptPrivateKey(publicKey, privateKey) {\n  var encryptedObj = ec_1.encryptECIES(publicKey, privateKey);\n  var encryptedJSON = JSON.stringify(encryptedObj);\n  return Buffer.from(encryptedJSON).toString('hex');\n}\n\nexports.encryptPrivateKey = encryptPrivateKey;\n/**\r\n * Decrypts the hex encrypted private key\r\n * @param  {String} privateKey  the private key corresponding to the public\r\n * key for which the ciphertext was encrypted\r\n * @param  {String} hexedEncrypted the ciphertext\r\n * @return {String}  the decrypted private key\r\n * @throws {Error} if unable to decrypt\r\n *\r\n * @private\r\n */\n\nfunction decryptPrivateKey(privateKey, hexedEncrypted) {\n  var unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n  var encryptedObj = JSON.parse(unhexedString);\n  var decrypted = ec_1.decryptECIES(privateKey, encryptedObj);\n\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\n\nexports.decryptPrivateKey = decryptPrivateKey;\n/**\r\n * Generates a signed authentication response token for an app. This\r\n * token is sent back to apps which use contents to access the\r\n * resources and data requested by the app.\r\n *\r\n * @param  {String} privateKey the identity key of the Blockstack ID generating\r\n * the authentication response\r\n * @param  {Object} profile the profile object for the Blockstack ID\r\n * @param  {String} username the username of the Blockstack ID if any, otherwise `null`\r\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\r\n * response including `email` if requested and available and a URL to the profile\r\n * @param  {String} coreToken core session token when responding to a legacy auth request\r\n * or `null` for current direct to gaia authentication requests\r\n * @param  {String} appPrivateKey the application private key. This private key is\r\n * unique and specific for every Blockstack ID and application combination.\r\n * @param  {Number} expiresAt an integer in the same format as\r\n * `new Date().getTime()`, milliseconds since the Unix epoch\r\n * @param {String} transitPublicKey the public key provide by the app\r\n * in its authentication request with which secrets will be encrypted\r\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\r\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\r\n * @param {String} associationToken JWT that binds the app key to the identity key\r\n * @return {String} signed and encoded authentication response token\r\n * @private\r\n */\n\nfunction makeAuthResponse(privateKey) {\n  var profile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var username = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var metadata = arguments.length > 3 ? arguments[3] : undefined;\n  var coreToken = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var appPrivateKey = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var expiresAt = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : utils_1.nextMonth().getTime();\n  var transitPublicKey = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  var hubUrl = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n  var blockstackAPIUrl = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var associationToken = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n\n  /* Convert the private key to a public key to an issuer */\n  var publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n  var address = keys_1.publicKeyToAddress(publicKey);\n  /* See if we should encrypt with the transit key */\n\n  var privateKeyPayload = appPrivateKey;\n  var coreTokenPayload = coreToken;\n  var additionalProperties = {};\n\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    logger_1.Logger.info(\"blockstack.js: generating v\".concat(VERSION, \" auth response\"));\n\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = encryptPrivateKey(transitPublicKey, appPrivateKey);\n\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n\n    additionalProperties = {\n      email: metadata.email ? metadata.email : null,\n      profile_url: metadata.profileUrl ? metadata.profileUrl : null,\n      hubUrl: hubUrl,\n      blockstackAPIUrl: blockstackAPIUrl,\n      associationToken: associationToken,\n      version: VERSION\n    };\n  } else {\n    logger_1.Logger.info('blockstack.js: generating legacy auth response');\n  }\n  /* Create the payload */\n\n\n  var payload = Object.assign({}, {\n    jti: utils_1.makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: dids_1.makeDIDFromAddress(address),\n    private_key: privateKeyPayload,\n    public_keys: [publicKey],\n    profile: profile,\n    username: username,\n    core_token: coreTokenPayload\n  }, additionalProperties);\n  /* Sign and return the token */\n\n  var tokenSigner = new jsontokens_1.TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}\n\nexports.makeAuthResponse = makeAuthResponse;","map":null,"metadata":{},"sourceType":"script"}