{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @ts-ignore: Could not find a declaration file for module\n\nvar jsontokens_1 = require(\"jsontokens\");\n\nrequire(\"cross-fetch/polyfill\");\n/**\r\n * Create an authentication token to be sent to the Core API server\r\n * in order to generate a Core session JWT.\r\n *\r\n * @param {String} appDomain  The unique application identifier (e.g. foo.app, www.foo.com, etc).\r\n * @param {Array} appMethods  The list of API methods this application will need.\r\n * @param {String} appPrivateKey  The application-specific private key\r\n * @param {String|null} blockchainID  This is the blockchain ID of the requester\r\n * @param {String} thisDevice Identifier of the current device\r\n *\r\n * @return {String} a JWT signed by the app's private key\r\n * @deprecated\r\n * @private\r\n */\n\n\nfunction makeCoreSessionRequest(appDomain, appMethods, appPrivateKey) {\n  var blockchainID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var thisDevice = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  if (thisDevice === null) {\n    thisDevice = '.default';\n  }\n\n  var appPublicKey = jsontokens_1.SECP256K1Client.derivePublicKey(appPrivateKey);\n  var appPublicKeys = [{\n    public_key: appPublicKey,\n    device_id: thisDevice\n  }];\n  var authBody = {\n    version: 1,\n    blockchain_id: blockchainID,\n    app_private_key: appPrivateKey,\n    app_domain: appDomain,\n    methods: appMethods,\n    app_public_keys: appPublicKeys,\n    device_id: thisDevice\n  }; // make token\n\n  var tokenSigner = new jsontokens_1.TokenSigner('ES256k', appPrivateKey);\n  var token = tokenSigner.sign(authBody);\n  return token;\n}\n\nexports.makeCoreSessionRequest = makeCoreSessionRequest;\n/**\r\n * Send Core a request for a session token.\r\n *\r\n * @param {String} coreHost host name of the core node\r\n * @param {Number} corePort port number of the core node\r\n * @param {String} coreAuthRequest  a signed JWT encoding the authentication request\r\n * @param {String} apiPassword the API password for Core\r\n *\r\n * @return {Promise} the resolves to a JWT signed with the Core API server's private key\r\n * that authorizes the bearer to carry out the requested operations and rejects\r\n * with an error message otherwise\r\n * @deprecated\r\n * @private\r\n */\n\nfunction sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword) {\n  return Promise.resolve().then(function () {\n    if (!apiPassword) {\n      throw new Error('Missing API password');\n    }\n  }).then(function () {\n    var options = {\n      headers: {\n        Authorization: \"bearer \".concat(apiPassword)\n      }\n    };\n    var url = \"http://\".concat(coreHost, \":\").concat(corePort, \"/v1/auth?authRequest=\").concat(coreAuthRequest);\n    return fetch(url, options);\n  }).then(function (response) {\n    if (!response.ok) {\n      throw new Error('HTTP status not OK');\n    }\n\n    return response.text();\n  }).then(function (responseText) {\n    var responseJson = JSON.parse(responseText);\n    var token = responseJson.token;\n\n    if (!token) {\n      throw new Error('Failed to get Core session token');\n    }\n\n    return token;\n  }).catch(function (error) {\n    console.error(error);\n    throw new Error('Invalid Core response: not JSON');\n  });\n}\n\nexports.sendCoreSessionRequest = sendCoreSessionRequest;\n/**\r\n * Get a core session token.  Generate an auth request, sign it, send it to Core,\r\n * and get back a session token.\r\n *\r\n * @param {String} coreHost Core API server's hostname\r\n * @param {Number} corePort Core API server's port number\r\n * @param {String} apiPassword core api password\r\n * @param  {String} appPrivateKey Application's private key\r\n * @param  {String} blockchainId blockchain ID of the user signing in.\r\n * `null` if user has no blockchain ID\r\n * @param {String} authRequest authentication request token\r\n * @param {String} deviceId identifier for the current device\r\n *\r\n * @return {Promise} a Promise that resolves to a Core session token or rejects\r\n * with an error message.\r\n * @deprecated\r\n * @private\r\n */\n\nfunction getCoreSession(coreHost, corePort, apiPassword, appPrivateKey) {\n  var blockchainId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var authRequest = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var deviceId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '0';\n\n  if (!authRequest) {\n    return Promise.reject('No authRequest provided');\n  }\n\n  var payload = null;\n  var authRequestObject = null;\n\n  try {\n    authRequestObject = jsontokens_1.decodeToken(authRequest);\n\n    if (!authRequestObject) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n\n    if (!authRequestObject.payload) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n\n    payload = authRequestObject.payload;\n  } catch (e) {\n    console.error(e.stack);\n    return Promise.reject('Failed to parse authRequest in URL');\n  }\n\n  var appDomain = payload.domain_name;\n\n  if (!appDomain) {\n    return Promise.reject('No domain_name in authRequest');\n  }\n\n  var appMethods = payload.scopes;\n  var coreAuthRequest = makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainId, deviceId);\n  return sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword);\n}\n\nexports.getCoreSession = getCoreSession;","map":null,"metadata":{},"sourceType":"script"}