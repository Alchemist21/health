{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar elliptic_1 = require(\"elliptic\");\n\nvar crypto_1 = __importDefault(require(\"crypto\"));\n\nvar keys_1 = require(\"../keys\");\n\nvar ecurve = new elliptic_1.ec('secp256k1');\n\nfunction aes256CbcEncrypt(iv, key, plaintext) {\n  var cipher = crypto_1.default.createCipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([cipher.update(plaintext), cipher.final()]);\n}\n\nfunction aes256CbcDecrypt(iv, key, ciphertext) {\n  var cipher = crypto_1.default.createDecipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([cipher.update(ciphertext), cipher.final()]);\n}\n\nfunction hmacSha256(key, content) {\n  return crypto_1.default.createHmac('sha256', key).update(content).digest();\n}\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  var res = 0;\n\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n\nfunction sharedSecretToKeys(sharedSecret) {\n  // generate mac and encryption key from shared secret\n  var hashedSecret = crypto_1.default.createHash('sha512').update(sharedSecret).digest();\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\n\nfunction getHexFromBN(bnInput) {\n  var hexOut = bnInput.toString('hex');\n\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    var padding = '0'.repeat(64 - hexOut.length);\n    return \"\".concat(padding).concat(hexOut);\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n\nexports.getHexFromBN = getHexFromBN;\n/**\r\n * Encrypt content to elliptic curve publicKey using ECIES\r\n * @param {String} publicKey - secp256k1 public key hex string\r\n * @param {String | Buffer} content - content to encrypt\r\n * @return {Object} Object containing (hex encoded):\r\n *  iv (initialization vector), cipherText (cipher text),\r\n *  mac (message authentication code), ephemeral public key\r\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\r\n *  @private\r\n */\n\nfunction encryptECIES(publicKey, content) {\n  var isString = typeof content === 'string'; // always copy to buffer\n\n  var plainText = content instanceof Buffer ? Buffer.from(content) : Buffer.from(content);\n  var ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n  var ephemeralSK = ecurve.genKeyPair();\n  var ephemeralPK = ephemeralSK.getPublic();\n  var sharedSecret = ephemeralSK.derive(ecPK);\n  var sharedSecretHex = getHexFromBN(sharedSecret);\n  var sharedKeys = sharedSecretToKeys(Buffer.from(sharedSecretHex, 'hex'));\n  var initializationVector = crypto_1.default.randomBytes(16);\n  var cipherText = aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, plainText);\n  var macData = Buffer.concat([initializationVector, Buffer.from(ephemeralPK.encodeCompressed()), cipherText]);\n  var mac = hmacSha256(sharedKeys.hmacKey, macData);\n  return {\n    iv: initializationVector.toString('hex'),\n    ephemeralPK: ephemeralPK.encodeCompressed('hex'),\n    cipherText: cipherText.toString('hex'),\n    mac: mac.toString('hex'),\n    wasString: isString\n  };\n}\n\nexports.encryptECIES = encryptECIES;\n/**\r\n * Decrypt content encrypted using ECIES\r\n * @param {String} privateKey - secp256k1 private key hex string\r\n * @param {Object} cipherObject - object to decrypt, should contain:\r\n *  iv (initialization vector), cipherText (cipher text),\r\n *  mac (message authentication code), ephemeralPublicKey\r\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\r\n * @return {Buffer} plaintext\r\n * @throws {Error} if unable to decrypt\r\n * @private\r\n */\n\nfunction decryptECIES(privateKey, cipherObject) {\n  var ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n  var ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n  var sharedSecret = ecSK.derive(ephemeralPK);\n  var sharedSecretBuffer = Buffer.from(getHexFromBN(sharedSecret), 'hex');\n  var sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n  var ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n  var cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n  var macData = Buffer.concat([ivBuffer, Buffer.from(ephemeralPK.encodeCompressed()), cipherTextBuffer]);\n  var actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n  var expectedMac = Buffer.from(cipherObject.mac, 'hex');\n\n  if (!equalConstTime(expectedMac, actualMac)) {\n    throw new Error('Decryption failed: failure in MAC check');\n  }\n\n  var plainText = aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n\n  if (cipherObject.wasString) {\n    return plainText.toString();\n  } else {\n    return plainText;\n  }\n}\n\nexports.decryptECIES = decryptECIES;\n/**\r\n * Sign content using ECDSA\r\n * @private\r\n * @param {String} privateKey - secp256k1 private key hex string\r\n * @param {Object} content - content to sign\r\n * @return {Object} contains:\r\n * signature - Hex encoded DER signature\r\n * public key - Hex encoded private string taken from privateKey\r\n * @private\r\n */\n\nfunction signECDSA(privateKey, content) {\n  var contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  var ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n  var publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n  var contentHash = crypto_1.default.createHash('sha256').update(contentBuffer).digest();\n  var signature = ecPrivate.sign(contentHash);\n  var signatureString = signature.toDER('hex');\n  return {\n    signature: signatureString,\n    publicKey: publicKey\n  };\n}\n\nexports.signECDSA = signECDSA;\n\nfunction getBuffer(content) {\n  if (content instanceof Buffer) return content;else if (content instanceof ArrayBuffer) return Buffer.from(content);else return Buffer.from(content);\n}\n/**\r\n * Verify content using ECDSA\r\n * @param {String | Buffer} content - Content to verify was signed\r\n * @param {String} publicKey - secp256k1 private key hex string\r\n * @param {String} signature - Hex encoded DER signature\r\n * @return {Boolean} returns true when signature matches publickey + content, false if not\r\n * @private\r\n */\n\n\nfunction verifyECDSA(content, publicKey, signature) {\n  var contentBuffer = getBuffer(content);\n  var ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n  var contentHash = crypto_1.default.createHash('sha256').update(contentBuffer).digest();\n  return ecPublic.verify(contentHash, signature);\n}\n\nexports.verifyECDSA = verifyECDSA;","map":null,"metadata":{},"sourceType":"script"}