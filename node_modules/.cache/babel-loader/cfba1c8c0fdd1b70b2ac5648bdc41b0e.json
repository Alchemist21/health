{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = __importStar(require(\"crypto\"));\n\nvar bitcoinjs_lib_1 = __importStar(require(\"bitcoinjs-lib\"));\n\nvar bip39_1 = __importDefault(require(\"bip39\"));\n\nvar bip32_1 = __importDefault(require(\"bip32\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar wallet_1 = require(\"./encryption/wallet\");\n\nvar APPS_NODE_INDEX = 0;\nvar IDENTITY_KEYCHAIN = 888;\nvar BLOCKSTACK_ON_BITCOIN = 0;\nvar BITCOIN_BIP_44_PURPOSE = 44;\nvar BITCOIN_COIN_TYPE = 0;\nvar BITCOIN_ACCOUNT_INDEX = 0;\nvar EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';\nvar CHANGE_ADDRESS = 'CHANGE_ADDRESS';\n\nfunction hashCode(string) {\n  var hash = 0;\n  if (string.length === 0) return hash;\n\n  for (var i = 0; i < string.length; i++) {\n    var character = string.charCodeAt(i);\n    hash = (hash << 5) - hash + character;\n    hash &= hash;\n  }\n\n  return hash & 0x7fffffff;\n}\n\nfunction getNodePrivateKey(node) {\n  return utils_1.ecPairToHexString(bitcoinjs_lib_1.ECPair.fromPrivateKey(node.privateKey));\n}\n\nfunction getNodePublicKey(node) {\n  return node.publicKey.toString('hex');\n}\n/**\r\n * The BlockstackWallet class manages the hierarchical derivation\r\n *  paths for a standard blockstack client wallet. This includes paths\r\n *  for bitcoin payment address, blockstack identity addresses, blockstack\r\n *  application specific addresses.\r\n *  @private\r\n */\n\n\nvar BlockstackWallet =\n/*#__PURE__*/\nfunction () {\n  function BlockstackWallet(rootNode) {\n    _classCallCheck(this, BlockstackWallet);\n\n    this.rootNode = rootNode;\n  }\n\n  _createClass(BlockstackWallet, [{\n    key: \"toBase58\",\n    value: function toBase58() {\n      return this.rootNode.toBase58();\n    }\n    /**\r\n     * Initialize a blockstack wallet from a seed buffer\r\n     * @param {Buffer} seed - the input seed for initializing the root node\r\n     *  of the hierarchical wallet\r\n     * @return {BlockstackWallet} the constructed wallet\r\n     */\n\n  }, {\n    key: \"getIdentityPrivateKeychain\",\n    value: function getIdentityPrivateKeychain() {\n      return this.rootNode.deriveHardened(IDENTITY_KEYCHAIN).deriveHardened(BLOCKSTACK_ON_BITCOIN);\n    }\n  }, {\n    key: \"getBitcoinPrivateKeychain\",\n    value: function getBitcoinPrivateKeychain() {\n      return this.rootNode.deriveHardened(BITCOIN_BIP_44_PURPOSE).deriveHardened(BITCOIN_COIN_TYPE).deriveHardened(BITCOIN_ACCOUNT_INDEX);\n    }\n  }, {\n    key: \"getBitcoinNode\",\n    value: function getBitcoinNode(addressIndex) {\n      var chainType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EXTERNAL_ADDRESS;\n      return BlockstackWallet.getNodeFromBitcoinKeychain(this.getBitcoinPrivateKeychain().toBase58(), addressIndex, chainType);\n    }\n  }, {\n    key: \"getIdentityAddressNode\",\n    value: function getIdentityAddressNode(identityIndex) {\n      var identityPrivateKeychain = this.getIdentityPrivateKeychain();\n      return identityPrivateKeychain.deriveHardened(identityIndex);\n    }\n  }, {\n    key: \"getIdentitySalt\",\n\n    /**\r\n     * Get a salt for use with creating application specific addresses\r\n     * @return {String} the salt\r\n     */\n    value: function getIdentitySalt() {\n      var identityPrivateKeychain = this.getIdentityPrivateKeychain();\n      var publicKeyHex = getNodePublicKey(identityPrivateKeychain);\n      return crypto_1.default.createHash('sha256').update(publicKeyHex).digest('hex');\n    }\n    /**\r\n     * Get a bitcoin receive address at a given index\r\n     * @param {number} addressIndex - the index of the address\r\n     * @return {String} address\r\n     */\n\n  }, {\n    key: \"getBitcoinAddress\",\n    value: function getBitcoinAddress(addressIndex) {\n      return BlockstackWallet.getAddressFromBIP32Node(this.getBitcoinNode(addressIndex));\n    }\n    /**\r\n     * Get the private key hex-string for a given bitcoin receive address\r\n     * @param {number} addressIndex - the index of the address\r\n     * @return {String} the hex-string. this will be either 64\r\n     * characters long to denote an uncompressed bitcoin address, or 66\r\n     * characters long for a compressed bitcoin address.\r\n     */\n\n  }, {\n    key: \"getBitcoinPrivateKey\",\n    value: function getBitcoinPrivateKey(addressIndex) {\n      return getNodePrivateKey(this.getBitcoinNode(addressIndex));\n    }\n    /**\r\n     * Get the root node for the bitcoin public keychain\r\n     * @return {String} base58-encoding of the public node\r\n     */\n\n  }, {\n    key: \"getBitcoinPublicKeychain\",\n    value: function getBitcoinPublicKeychain() {\n      return this.getBitcoinPrivateKeychain().neutered();\n    }\n    /**\r\n     * Get the root node for the identity public keychain\r\n     * @return {String} base58-encoding of the public node\r\n     */\n\n  }, {\n    key: \"getIdentityPublicKeychain\",\n    value: function getIdentityPublicKeychain() {\n      return this.getIdentityPrivateKeychain().neutered();\n    }\n  }, {\n    key: \"getIdentityKeyPair\",\n\n    /**\r\n     * Get the keypair information for a given identity index. This\r\n     * information is used to obtain the private key for an identity address\r\n     * and derive application specific keys for that address.\r\n     * @param {number} addressIndex - the identity index\r\n     * @param {boolean} alwaysUncompressed - if true, always return a\r\n     *   private-key hex string corresponding to the uncompressed address\r\n     * @return {Object} an IdentityKeyPair type object with keys:\r\n     *   .key {String} - the private key hex-string\r\n     *   .keyID {String} - the public key hex-string\r\n     *   .address {String} - the identity address\r\n     *   .appsNodeKey {String} - the base-58 encoding of the applications node\r\n     *   .salt {String} - the salt used for creating app-specific addresses\r\n     */\n    value: function getIdentityKeyPair(addressIndex) {\n      var alwaysUncompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var identityNode = this.getIdentityAddressNode(addressIndex);\n      var address = BlockstackWallet.getAddressFromBIP32Node(identityNode);\n      var identityKey = getNodePrivateKey(identityNode);\n\n      if (alwaysUncompressed && identityKey.length === 66) {\n        identityKey = identityKey.slice(0, 64);\n      }\n\n      var identityKeyID = getNodePublicKey(identityNode);\n      var appsNodeKey = BlockstackWallet.getAppsNode(identityNode).toBase58();\n      var salt = this.getIdentitySalt();\n      var keyPair = {\n        key: identityKey,\n        keyID: identityKeyID,\n        address: address,\n        appsNodeKey: appsNodeKey,\n        salt: salt\n      };\n      return keyPair;\n    }\n  }], [{\n    key: \"fromSeedBuffer\",\n    value: function fromSeedBuffer(seed) {\n      return new BlockstackWallet(bip32_1.default.fromSeed(seed));\n    }\n    /**\r\n     * Initialize a blockstack wallet from a base58 string\r\n     * @param {string} keychain - the Base58 string used to initialize\r\n     *  the root node of the hierarchical wallet\r\n     * @return {BlockstackWallet} the constructed wallet\r\n     */\n\n  }, {\n    key: \"fromBase58\",\n    value: function fromBase58(keychain) {\n      return new BlockstackWallet(bip32_1.default.fromBase58(keychain));\n    }\n    /**\r\n     * Initialize a blockstack wallet from an encrypted phrase & password. Throws\r\n     * if the password is incorrect. Supports all formats of Blockstack phrases.\r\n     * @param {string} data - The encrypted phrase as a hex-encoded string\r\n     * @param {string} password - The plain password\r\n     * @return {Promise<BlockstackWallet>} the constructed wallet\r\n     */\n\n  }, {\n    key: \"fromEncryptedMnemonic\",\n    value: function fromEncryptedMnemonic(data, password) {\n      return wallet_1.decryptMnemonic(data, password).then(function (mnemonic) {\n        var seed = bip39_1.default.mnemonicToSeed(mnemonic);\n        return new BlockstackWallet(bip32_1.default.fromSeed(seed));\n      }).catch(function (err) {\n        if (err.message && err.message.startsWith('bad header;')) {\n          throw new Error('Incorrect password');\n        } else {\n          throw err;\n        }\n      });\n    }\n    /**\r\n     * Generate a BIP-39 12 word mnemonic\r\n     * @return {Promise<string>} space-separated 12 word phrase\r\n     */\n\n  }, {\n    key: \"generateMnemonic\",\n    value: function generateMnemonic() {\n      return bip39_1.default.generateMnemonic(128, crypto_1.randomBytes);\n    }\n    /**\r\n     * Encrypt a mnemonic phrase with a password\r\n     * @param {string} mnemonic - Raw mnemonic phrase\r\n     * @param {string} password - Password to encrypt mnemonic with\r\n     * @return {Promise<string>} Hex-encoded encrypted mnemonic\r\n     */\n\n  }, {\n    key: \"encryptMnemonic\",\n    value: function encryptMnemonic(mnemonic, password) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var encryptedBuffer;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return wallet_1.encryptMnemonic(mnemonic, password);\n\n              case 2:\n                encryptedBuffer = _context.sent;\n                return _context.abrupt(\"return\", encryptedBuffer.toString('hex'));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }, {\n    key: \"getAppsNode\",\n    value: function getAppsNode(identityNode) {\n      return identityNode.deriveHardened(APPS_NODE_INDEX);\n    }\n  }, {\n    key: \"getNodeFromBitcoinKeychain\",\n    value: function getNodeFromBitcoinKeychain(keychainBase58, addressIndex) {\n      var chainType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EXTERNAL_ADDRESS;\n      var chain;\n\n      if (chainType === EXTERNAL_ADDRESS) {\n        chain = 0;\n      } else if (chainType === CHANGE_ADDRESS) {\n        chain = 1;\n      } else {\n        throw new Error('Invalid chain type');\n      }\n\n      var keychain = bip32_1.default.fromBase58(keychainBase58);\n      return keychain.derive(chain).derive(addressIndex);\n    }\n    /**\r\n     * Get a bitcoin address given a base-58 encoded bitcoin node\r\n     * (usually called the account node)\r\n     * @param {String} keychainBase58 - base58-encoding of the node\r\n     * @param {number} addressIndex - index of the address to get\r\n     * @param {String} chainType - either 'EXTERNAL_ADDRESS' (for a\r\n     * \"receive\" address) or 'CHANGE_ADDRESS'\r\n     * @return {String} the address\r\n     */\n\n  }, {\n    key: \"getAddressFromBitcoinKeychain\",\n    value: function getAddressFromBitcoinKeychain(keychainBase58, addressIndex) {\n      var chainType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EXTERNAL_ADDRESS;\n      return BlockstackWallet.getAddressFromBIP32Node(BlockstackWallet.getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType));\n    }\n    /**\r\n     * Get a ECDSA private key hex-string for an application-specific\r\n     *  address.\r\n     * @param {String} appsNodeKey - the base58-encoded private key for\r\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\r\n     * @param {String} salt - a string, used to salt the\r\n     * application-specific addresses\r\n     * @param {String} appDomain - the appDomain to generate a key for\r\n     * @return {String} the private key hex-string. this will be a 64\r\n     * character string\r\n     */\n\n  }, {\n    key: \"getLegacyAppPrivateKey\",\n    value: function getLegacyAppPrivateKey(appsNodeKey, salt, appDomain) {\n      var hash = crypto_1.default.createHash('sha256').update(\"\".concat(appDomain).concat(salt)).digest('hex');\n      var appIndex = hashCode(hash);\n      var appNode = bip32_1.default.fromBase58(appsNodeKey).deriveHardened(appIndex);\n      return getNodePrivateKey(appNode).slice(0, 64);\n    }\n  }, {\n    key: \"getAddressFromBIP32Node\",\n    value: function getAddressFromBIP32Node(node) {\n      return bitcoinjs_lib_1.default.payments.p2pkh({\n        pubkey: node.publicKey\n      }).address;\n    }\n    /**\r\n     * Get a ECDSA private key hex-string for an application-specific\r\n     *  address.\r\n     * @param {String} appsNodeKey - the base58-encoded private key for\r\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\r\n     * @param {String} salt - a string, used to salt the\r\n     * application-specific addresses\r\n     * @param {String} appDomain - the appDomain to generate a key for\r\n     * @return {String} the private key hex-string. this will be a 64\r\n     * character string\r\n     */\n\n  }, {\n    key: \"getAppPrivateKey\",\n    value: function getAppPrivateKey(appsNodeKey, salt, appDomain) {\n      var hash = crypto_1.default.createHash('sha256').update(\"\".concat(appDomain).concat(salt)).digest('hex');\n      var appIndexHexes = []; // note: there's hardcoded numbers here, precisely because I want this\n      //   code to be very specific to the derivation paths we expect.\n\n      if (hash.length !== 64) {\n        throw new Error(\"Unexpected app-domain hash length of \".concat(hash.length));\n      }\n\n      for (var i = 0; i < 11; i++) {\n        // split the hash into 3-byte chunks\n        // because child nodes can only be up to 2^31,\n        // and we shouldn't deal in partial bytes.\n        appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));\n      }\n\n      var appNode = bip32_1.default.fromBase58(appsNodeKey);\n      appIndexHexes.forEach(function (hex) {\n        if (hex.length > 6) {\n          throw new Error('Invalid hex string length');\n        }\n\n        appNode = appNode.deriveHardened(parseInt(hex, 16));\n      });\n      return getNodePrivateKey(appNode).slice(0, 64);\n    }\n  }]);\n\n  return BlockstackWallet;\n}();\n\nexports.BlockstackWallet = BlockstackWallet;","map":null,"metadata":{},"sourceType":"script"}