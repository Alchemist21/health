{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Me\\\\Desktop\\\\hackfest2019\\\\healthr\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bitcoinjs_lib_1 = __importDefault(require(\"bitcoinjs-lib\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar skeletons_1 = require(\"./skeletons\");\n\nvar config_1 = require(\"../config\");\n\nvar errors_1 = require(\"../errors\");\n\nvar signers_1 = require(\"./signers\");\n\nvar dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';\nvar dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';\n\nfunction addOwnerInput(utxos, ownerAddress, txB) {\n  var addChangeOut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n  // add an owner UTXO and a change out.\n  if (utxos.length <= 0) {\n    throw new Error('Owner has no UTXOs for UPDATE.');\n  }\n\n  utxos.sort(function (a, b) {\n    return a.value - b.value;\n  });\n  var ownerUTXO = utxos[0];\n  var ownerInput = txB.addInput(ownerUTXO.tx_hash, ownerUTXO.tx_output_n);\n\n  if (addChangeOut) {\n    txB.addOutput(ownerAddress, ownerUTXO.value);\n  }\n\n  return {\n    index: ownerInput,\n    value: ownerUTXO.value\n  };\n}\n\nfunction fundTransaction(txB, paymentAddress, utxos, feeRate, inAmounts) {\n  var changeIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n\n  // change index for the payer.\n  if (changeIndex === null) {\n    changeIndex = txB.addOutput(paymentAddress, utils_1.DUST_MINIMUM);\n  } // fund the transaction fee.\n\n\n  var txFee = utils_1.estimateTXBytes(txB, 0, 0) * feeRate;\n  var outAmounts = utils_1.sumOutputValues(txB);\n  var change = utils_1.addUTXOsToFund(txB, utxos, txFee + outAmounts - inAmounts, feeRate);\n  var txInner = utils_1.getTransactionInsideBuilder(txB);\n  txInner.outs[changeIndex].value += change;\n  return txB;\n}\n\nfunction returnTransactionHex(txB) {\n  var buildIncomplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (buildIncomplete) {\n    return txB.buildIncomplete().toHex();\n  } else {\n    return txB.build().toHex();\n  }\n}\n\nfunction getTransactionSigner(input) {\n  if (typeof input === 'string') {\n    return signers_1.PubkeyHashSigner.fromHexString(input);\n  } else {\n    return input;\n  }\n}\n/**\r\n * Estimates cost of a preorder transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to preorder\r\n * @param {String} destinationAddress - the address to receive the name (this\r\n *    must be passed as the 'registrationAddress' in the register transaction)\r\n * @param {String} paymentAddress - the address funding the preorder\r\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\r\n *    from the payment address.\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\r\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\r\n *    Even though this is a change output, the payer must supply enough funds\r\n *    to generate this output, so we include it in the cost.\r\n * @private\r\n */\n\n\nfunction estimatePreorder(fullyQualifiedName, destinationAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var preorderPromise = network.getNamePrice(fullyQualifiedName).then(function (namePrice) {\n    return skeletons_1.makePreorderSkeleton(fullyQualifiedName, dummyConsensusHash, paymentAddress, network.getDefaultBurnAddress(), namePrice, destinationAddress);\n  });\n  return Promise.all([network.getFeeRate(), preorderPromise]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        feeRate = _ref2[0],\n        preorderTX = _ref2[1];\n\n    var outputsValue = utils_1.sumOutputValues(preorderTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates cost of a register transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to register\r\n * @param {String} registerAddress - the address to receive the name\r\n * @param {String} paymentAddress - the address funding the register\r\n * @param {Boolean} includingZonefile - whether or not we will broadcast\r\n *    a zonefile hash as part  of the register\r\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\r\n *    from the payment address.\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\r\n *    the register.\r\n * @private\r\n */\n\n\nfunction estimateRegister(fullyQualifiedName, registerAddress, paymentAddress) {\n  var includingZonefile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var paymentUtxos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var network = config_1.config.network;\n  var valueHash;\n\n  if (includingZonefile) {\n    valueHash = dummyZonefileHash;\n  }\n\n  var registerTX = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(registerTX); // 1 additional output for payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(registerTX, paymentUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates cost of an update transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to update\r\n * @param {String} ownerAddress - the owner of the name\r\n * @param {String} paymentAddress - the address funding the update\r\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\r\n *    from the payment address.\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\r\n *    the update.\r\n * @private\r\n */\n\n\nfunction estimateUpdate(fullyQualifiedName, ownerAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var updateTX = skeletons_1.makeUpdateSkeleton(fullyQualifiedName, dummyConsensusHash, dummyZonefileHash);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(updateTX); // 1 additional input for the owner\n    // 2 additional outputs for owner / payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(updateTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates cost of an transfer transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to transfer\r\n * @param {String} destinationAddress - the next owner of the name\r\n * @param {String} ownerAddress - the current owner of the name\r\n * @param {String} paymentAddress - the address funding the transfer\r\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\r\n *    from the payment address.\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\r\n *    the transfer.\r\n * @private\r\n */\n\n\nfunction estimateTransfer(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var network = config_1.config.network;\n  var transferTX = skeletons_1.makeTransferSkeleton(fullyQualifiedName, dummyConsensusHash, destinationAddress);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(transferTX); // 1 additional input for the owner\n    // 2 additional outputs for owner / payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(transferTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates cost of an transfer transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to renew\r\n * @param {String} destinationAddress - the next owner of the name\r\n * @param {String} ownerAddress - the current owner of the name\r\n * @param {String} paymentAddress - the address funding the transfer\r\n * @param {Boolean} includingZonefile - whether or not we will broadcast a zonefile hash\r\n      in the renewal operation\r\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\r\n *    from the payment address.\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\r\n *    the transfer.\r\n * @private\r\n */\n\n\nfunction estimateRenewal(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress) {\n  var includingZonefile = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var paymentUtxos = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  var network = config_1.config.network;\n  var valueHash;\n\n  if (includingZonefile) {\n    valueHash = dummyZonefileHash;\n  }\n\n  var renewalPromise = network.getNamePrice(fullyQualifiedName).then(function (namePrice) {\n    return skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, network.getDefaultBurnAddress(), namePrice, valueHash);\n  });\n  return Promise.all([network.getFeeRate(), renewalPromise]).then(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        feeRate = _ref4[0],\n        renewalTX = _ref4[1];\n\n    var outputsValue = utils_1.sumOutputValues(renewalTX); // 1 additional input for the owner\n    // and renewal skeleton includes all outputs for owner change, but not for payer change.\n\n    var txFee = feeRate * utils_1.estimateTXBytes(renewalTX, 1 + paymentUtxos, 1);\n    return txFee + outputsValue - 5500; // don't count the dust change for old owner.\n  });\n}\n/**\r\n * Estimates cost of a revoke transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to revoke\r\n * @param {String} ownerAddress - the current owner of the name\r\n * @param {String} paymentAddress  the address funding the revoke\r\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\r\n *    from the payment address.\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund the\r\n *    revoke.\r\n * @private\r\n */\n\n\nfunction estimateRevoke(fullyQualifiedName, ownerAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n  return Promise.all([network.getFeeRate()]).then(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n        feeRate = _ref6[0];\n\n    var outputsValue = utils_1.sumOutputValues(revokeTX); // 1 additional input for owner\n    // 1 additional output for payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(revokeTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates cost of a namespace preorder transaction for a namespace\r\n * @param {String} namespaceID - the namespace to preorder\r\n * @param {String} revealAddress - the address to receive the namespace (this\r\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\r\n * @param {String} paymentAddress - the address funding the preorder\r\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\r\n *    from the payment address.\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\r\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\r\n *    Even though this is a change output, the payer must supply enough funds\r\n *    to generate this output, so we include it in the cost.\r\n * @private\r\n */\n\n\nfunction estimateNamespacePreorder(namespaceID, revealAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var preorderPromise = network.getNamespacePrice(namespaceID).then(function (namespacePrice) {\n    return skeletons_1.makeNamespacePreorderSkeleton(namespaceID, dummyConsensusHash, paymentAddress, revealAddress, namespacePrice);\n  });\n  return Promise.all([network.getFeeRate(), preorderPromise]).then(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n        feeRate = _ref8[0],\n        preorderTX = _ref8[1];\n\n    var outputsValue = utils_1.sumOutputValues(preorderTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates cost of a namesapce reveal transaction for a namespace\r\n * @param {BlockstackNamespace} namespace - the namespace to reveal\r\n * @param {String} revealAddress - the address to receive the namespace\r\n *    (this must have been passed as 'revealAddress' to a prior namespace\r\n *    preorder)\r\n * @param {String} paymentAddress - the address that pays for this transaction\r\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\r\n *    from the payment address\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to\r\n *    fund the reveal.  This includes a 5500 satoshi dust output for the\r\n *    preorder.  Even though this is a change output, the payer must have\r\n *    enough funds to generate this output, so we include it in the cost.\r\n * @private\r\n */\n\n\nfunction estimateNamespaceReveal(namespace, revealAddress, paymentAddress) {\n  var paymentUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var revealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(revealTX); // 1 additional output for payer change\n\n    var txFee = feeRate * utils_1.estimateTXBytes(revealTX, paymentUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates the cost of a namespace-ready transaction for a namespace\r\n * @param {String} namespaceID - the namespace to ready\r\n * @param {Number} revealUtxos - the number of UTXOs we expect will\r\n *  be required from the reveal address\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to\r\n *  fund this namespacey-ready transaction.\r\n * @private\r\n */\n\n\nfunction estimateNamespaceReady(namespaceID) {\n  var revealUtxos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var network = config_1.config.network;\n  var readyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(readyTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(readyTX, revealUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates the cost of a name-import transaction\r\n * @param {String} name - the fully-qualified name\r\n * @param {String} recipientAddr - the recipient\r\n * @param {String} zonefileHash - the zone file hash\r\n * @param {Number} importUtxos - the number of UTXOs we expect will\r\n *  be required from the importer address\r\n * @returns {Promise} - a promise which resolves to the satoshi cost\r\n *  to fund this name-import transaction\r\n * @private\r\n */\n\n\nfunction estimateNameImport(name, recipientAddr, zonefileHash) {\n  var importUtxos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var network = config_1.config.network;\n  var importTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(importTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(importTX, importUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates the cost of an announce transaction\r\n * @param {String} messageHash - the hash of the message\r\n * @param {Number} senderUtxos - the number of utxos we expect will\r\n *  be required from the importer address\r\n * @returns {Promise} - a promise which resolves to the satoshi cost\r\n *  to fund this announce transaction\r\n * @private\r\n */\n\n\nfunction estimateAnnounce(messageHash) {\n  var senderUtxos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var network = config_1.config.network;\n  var announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(announceTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(announceTX, senderUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Estimates the cost of a token-transfer transaction\r\n * @param {String} recipientAddress - the recipient of the tokens\r\n * @param {String} tokenType - the type of token to spend\r\n * @param {Object} tokenAmount - a 64-bit unsigned BigInteger encoding the number of tokens\r\n *   to spend\r\n * @param {String} scratchArea - an arbitrary string to store with the transaction\r\n * @param {Number} senderUtxos - the number of utxos we expect will\r\n *  be required from the importer address\r\n * @param {Number} additionalOutputs - the number of outputs we expect to add beyond\r\n *  just the recipient output (default = 1, if the token owner is also the bitcoin funder)\r\n * @returns {Promise} - a promise which resolves to the satoshi cost to\r\n *  fund this token-transfer transaction\r\n * @private\r\n */\n\n\nfunction estimateTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea) {\n  var senderUtxos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var additionalOutputs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  var network = config_1.config.network;\n  var tokenTransferTX = skeletons_1.makeTokenTransferSkeleton(recipientAddress, dummyConsensusHash, tokenType, tokenAmount, scratchArea);\n  return network.getFeeRate().then(function (feeRate) {\n    var outputsValue = utils_1.sumOutputValues(tokenTransferTX);\n    var txFee = feeRate * utils_1.estimateTXBytes(tokenTransferTX, senderUtxos, additionalOutputs);\n    return txFee + outputsValue;\n  });\n}\n/**\r\n * Generates a preorder transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to pre-order\r\n * @param {String} destinationAddress - the address to receive the name (this\r\n *    must be passed as the 'registrationAddress' in the register transaction)\r\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\r\n *    the private key used to fund the transaction or a transaction signer object\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n * transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n *    this function *does not* perform the requisite safety checks -- please see\r\n *    the safety module for those.\r\n * @private\r\n */\n\n\nfunction makePreorder(fullyQualifiedName, destinationAddress, paymentKeyIn) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var network = config_1.config.network;\n  var namespace = fullyQualifiedName.split('.').pop();\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (preorderAddress) {\n    var preorderPromise = Promise.all([network.getConsensusHash(), network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 3),\n          consensusHash = _ref10[0],\n          namePrice = _ref10[1],\n          burnAddress = _ref10[2];\n\n      return skeletons_1.makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress);\n    });\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(function (_ref11) {\n      var _ref12 = _slicedToArray(_ref11, 3),\n          utxos = _ref12[0],\n          feeRate = _ref12[1],\n          preorderSkeleton = _ref12[2];\n\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n      txB.setVersion(1);\n      var changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n\n      var signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    }).then(function (signingTxB) {\n      return returnTransactionHex(signingTxB, buildIncomplete);\n    });\n  });\n}\n/**\r\n * Generates an update transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to update\r\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of the\r\n *    owner key, or a transaction signer object. This will provide one\r\n *    UTXO input, and also recieve a dust output.\r\n * @param {String | TransactionSigner} paymentKeyIn - a hex string, or a\r\n *    transaction signer object, of the private key used to fund the\r\n *    transaction's txfees\r\n * @param {String} zonefile - the zonefile data to update (this will be hashed\r\n *    to include in the transaction), the zonefile itself must be published\r\n *    after the UPDATE propagates.\r\n * @param {String} valueHash - if given, this is the hash to store (instead of\r\n *    zonefile).  zonefile will be ignored if this is given.\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n *    transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n *    this function *does not* perform the requisite safety checks -- please see\r\n *    the safety module for those.\r\n * @private\r\n */\n\n\nfunction makeUpdate(fullyQualifiedName, ownerKeyIn, paymentKeyIn, zonefile) {\n  var valueHash = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n  var buildIncomplete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var network = config_1.config.network;\n\n  if (!valueHash && !zonefile) {\n    return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n  }\n\n  if (valueHash.length === 0) {\n    if (!zonefile) {\n      return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n    }\n\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  } else if (valueHash.length !== 40) {\n    return Promise.reject(new Error(\"Invalid valueHash \".concat(valueHash)));\n  }\n\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  var ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(function (_ref13) {\n    var _ref14 = _slicedToArray(_ref13, 2),\n        ownerAddress = _ref14[0],\n        paymentAddress = _ref14[1];\n\n    var txPromise = network.getConsensusHash().then(function (consensusHash) {\n      return skeletons_1.makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash);\n    }).then(function (updateTX) {\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(updateTX, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref15) {\n      var _ref16 = _slicedToArray(_ref15, 4),\n          txB = _ref16[0],\n          payerUtxos = _ref16[1],\n          ownerUtxos = _ref16[2],\n          feeRate = _ref16[3];\n\n      var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates a register transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to register\r\n * @param {String} registerAddress - the address to receive the name (this\r\n *    must have been passed as the 'destinationAddress' in the preorder transaction)\r\n *    this address will receive a dust UTXO\r\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\r\n *    the private key (or a TransactionSigner object) used to fund the\r\n *    transaction (this *must* be the same as the payment address used\r\n *    to fund the preorder)\r\n * @param {String} zonefile - the zonefile data to include (this will be hashed\r\n *    to include in the transaction), the zonefile itself must be published\r\n *    after the UPDATE propagates.\r\n * @param {String} valueHash - the hash of the zone file data to include.\r\n *    It will be used instead of zonefile, if given\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n *    transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n *    this function *does not* perform the requisite safety checks -- please see\r\n *    the safety module for those.\r\n * @private\r\n */\n\n\nfunction makeRegister(fullyQualifiedName, registerAddress, paymentKeyIn) {\n  var zonefile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var valueHash = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var buildIncomplete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var network = config_1.config.network;\n\n  if (!valueHash && !!zonefile) {\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  } else if (!!valueHash && valueHash.length !== 40) {\n    return Promise.reject(new Error(\"Invalid zonefile hash \".concat(valueHash)));\n  }\n\n  var registerSkeleton = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n  var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(registerSkeleton, network.layer1);\n  txB.setVersion(1);\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (paymentAddress) {\n    return Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(function (_ref17) {\n      var _ref18 = _slicedToArray(_ref17, 2),\n          utxos = _ref18[0],\n          feeRate = _ref18[1];\n\n      var signingTxB = fundTransaction(txB, paymentAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates a transfer transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to transfer\r\n * @param {String} destinationAddress - the address to receive the name.\r\n *    this address will receive a dust UTXO\r\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\r\n *    the current owner's private key (or a TransactionSigner object)\r\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\r\n *    the private key used to fund the transaction (or a\r\n *    TransactionSigner object)\r\n * @param {Boolean} keepZonefile - if true, then preserve the name's zone file\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n *   transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n *    this function *does not* perform the requisite safety checks -- please see\r\n *    the safety module for those.\r\n * @private\r\n */\n\n\nfunction makeTransfer(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn) {\n  var keepZonefile = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var buildIncomplete = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var network = config_1.config.network;\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  var ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(function (_ref19) {\n    var _ref20 = _slicedToArray(_ref19, 2),\n        ownerAddress = _ref20[0],\n        paymentAddress = _ref20[1];\n\n    var txPromise = network.getConsensusHash().then(function (consensusHash) {\n      return skeletons_1.makeTransferSkeleton(fullyQualifiedName, consensusHash, destinationAddress, keepZonefile);\n    }).then(function (transferTX) {\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(transferTX, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref21) {\n      var _ref22 = _slicedToArray(_ref21, 4),\n          txB = _ref22[0],\n          payerUtxos = _ref22[1],\n          ownerUtxos = _ref22[2],\n          feeRate = _ref22[3];\n\n      var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates a revoke transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to revoke\r\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\r\n *    the current owner's private key (or a TransactionSigner object)\r\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\r\n *    the private key used to fund the transaction (or a\r\n *    TransactionSigner object)\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n *    transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n *    this function *does not* perform the requisite safety checks -- please see\r\n *    the safety module for those.\r\n * @private\r\n */\n\n\nfunction makeRevoke(fullyQualifiedName, ownerKeyIn, paymentKeyIn) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var network = config_1.config.network;\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  var ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(function (_ref23) {\n    var _ref24 = _slicedToArray(_ref23, 2),\n        ownerAddress = _ref24[0],\n        paymentAddress = _ref24[1];\n\n    var revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n    var txPromise = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(revokeTX, network.layer1);\n    txPromise.setVersion(1);\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref25) {\n      var _ref26 = _slicedToArray(_ref25, 4),\n          txB = _ref26[0],\n          payerUtxos = _ref26[1],\n          ownerUtxos = _ref26[2],\n          feeRate = _ref26[3];\n\n      var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates a renewal transaction for a domain name.\r\n * @param {String} fullyQualifiedName - the name to transfer\r\n * @param {String} destinationAddress - the address to receive the name after renewal\r\n *    this address will receive a dust UTXO\r\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\r\n *    the current owner's private key (or a TransactionSigner object)\r\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\r\n *    the private key used to fund the renewal (or a TransactionSigner\r\n *    object)\r\n * @param {String} zonefile - the zonefile data to include, if given (this will be hashed\r\n *    to include in the transaction), the zonefile itself must be published\r\n *    after the RENEWAL propagates.\r\n * @param {String} valueHash - the raw zone file hash to include (this will be used\r\n *    instead of zonefile, if given).\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n *    transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n *    this function *does not* perform the requisite safety checks -- please see\r\n *    the safety module for those.\r\n * @private\r\n */\n\n\nfunction makeRenewal(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn) {\n  var zonefile = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var valueHash = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var buildIncomplete = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var network = config_1.config.network;\n\n  if (!valueHash && !!zonefile) {\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  }\n\n  var namespace = fullyQualifiedName.split('.').pop();\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  var ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(function (_ref27) {\n    var _ref28 = _slicedToArray(_ref27, 2),\n        ownerAddress = _ref28[0],\n        paymentAddress = _ref28[1];\n\n    var txPromise = Promise.all([network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(function (_ref29) {\n      var _ref30 = _slicedToArray(_ref29, 2),\n          namePrice = _ref30[0],\n          burnAddress = _ref30[1];\n\n      return skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash);\n    }).then(function (tx) {\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(tx, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(function (_ref31) {\n      var _ref32 = _slicedToArray(_ref31, 4),\n          txB = _ref32[0],\n          payerUtxos = _ref32[1],\n          ownerUtxos = _ref32[2],\n          feeRate = _ref32[3];\n\n      var ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB, false);\n      var txInner = utils_1.getTransactionInsideBuilder(txB);\n      var ownerOutput = txInner.outs[2];\n      var ownerOutputAddr = bitcoinjs_lib_1.default.address.fromOutputScript(ownerOutput.script, network.layer1);\n\n      if (ownerOutputAddr !== ownerAddress) {\n        return Promise.reject(new Error(\"Original owner \".concat(ownerAddress, \" should have an output at \") + \"index 2 in transaction was \".concat(ownerOutputAddr)));\n      }\n\n      ownerOutput.value = ownerInput.value;\n      var signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates a namespace preorder transaction for a namespace\r\n * @param {String} namespaceID - the namespace to pre-order\r\n * @param {String} revealAddress - the address to receive the namespace (this\r\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\r\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\r\n *    the private key used to fund the transaction (or a\r\n *    TransactionSigner object)\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n *    transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n *    this function *does not* perform the requisite safety checks -- please see\r\n *    the safety module for those.\r\n * @private\r\n */\n\n\nfunction makeNamespacePreorder(namespaceID, revealAddress, paymentKeyIn) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var network = config_1.config.network;\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (preorderAddress) {\n    var preorderPromise = Promise.all([network.getConsensusHash(), network.getNamespacePrice(namespaceID)]).then(function (_ref33) {\n      var _ref34 = _slicedToArray(_ref33, 2),\n          consensusHash = _ref34[0],\n          namespacePrice = _ref34[1];\n\n      return skeletons_1.makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, revealAddress, namespacePrice);\n    });\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(function (_ref35) {\n      var _ref36 = _slicedToArray(_ref35, 3),\n          utxos = _ref36[0],\n          feeRate = _ref36[1],\n          preorderSkeleton = _ref36[2];\n\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n      txB.setVersion(1);\n      var changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n\n      var signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    }).then(function (signingTxB) {\n      return returnTransactionHex(signingTxB, buildIncomplete);\n    });\n  });\n}\n/**\r\n * Generates a namespace reveal transaction for a namespace\r\n * @param {BlockstackNamespace} namespace - the namespace to reveal\r\n * @param {String} revealAddress - the address to receive the namespace (this\r\n *   must be passed as the 'revealAddress' in the namespace-reveal transaction)\r\n * @param {String | TransactionSigner} paymentKeyIn - a hex string (or\r\n *   a TransactionSigner object) of the private key used to fund the\r\n *   transaction\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n *   transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n *   this function *does not* perform the requisite safety checks -- please see\r\n *   the safety module for those.\r\n * @private\r\n */\n\n\nfunction makeNamespaceReveal(namespace, revealAddress, paymentKeyIn) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var network = config_1.config.network;\n\n  if (!namespace.check()) {\n    return Promise.reject(new Error('Invalid namespace'));\n  }\n\n  var namespaceRevealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (preorderAddress) {\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate()]).then(function (_ref37) {\n      var _ref38 = _slicedToArray(_ref37, 2),\n          utxos = _ref38[0],\n          feeRate = _ref38[1];\n\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(namespaceRevealTX, network.layer1);\n      txB.setVersion(1);\n      var signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates a namespace ready transaction for a namespace\r\n * @param {String} namespaceID - the namespace to launch\r\n * @param {String | TransactionSigner} revealKeyIn - the private key\r\n *  of the 'revealAddress' used to reveal the namespace\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n *  indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n *  transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n *  this function *does not* perform the requisite safety checks -- please see\r\n *  the safety module for those.\r\n * @private\r\n */\n\n\nfunction makeNamespaceReady(namespaceID, revealKeyIn) {\n  var buildIncomplete = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var network = config_1.config.network;\n  var namespaceReadyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n  var revealKey = getTransactionSigner(revealKeyIn);\n  return revealKey.getAddress().then(function (revealAddress) {\n    return Promise.all([network.getUTXOs(revealAddress), network.getFeeRate()]).then(function (_ref39) {\n      var _ref40 = _slicedToArray(_ref39, 2),\n          utxos = _ref40[0],\n          feeRate = _ref40[1];\n\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(namespaceReadyTX, network.layer1);\n      txB.setVersion(1);\n      var signingTxB = fundTransaction(txB, revealAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, revealKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates a name import transaction for a namespace\r\n * @param {String} name - the name to import\r\n * @param {String} recipientAddr - the address to receive the name\r\n * @param {String} zonefileHash - the hash of the zonefile to give this name\r\n * @param {String | TransactionSigner} importerKeyIn - the private key\r\n * that pays for the import\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n * transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n * this function does not perform the requisite safety checks -- please see\r\n * the safety module for those.\r\n * @private\r\n */\n\n\nfunction makeNameImport(name, recipientAddr, zonefileHash, importerKeyIn) {\n  var buildIncomplete = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var network = config_1.config.network;\n  var nameImportTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n  var importerKey = getTransactionSigner(importerKeyIn);\n  return importerKey.getAddress().then(function (importerAddress) {\n    return Promise.all([network.getUTXOs(importerAddress), network.getFeeRate()]).then(function (_ref41) {\n      var _ref42 = _slicedToArray(_ref41, 2),\n          utxos = _ref42[0],\n          feeRate = _ref42[1];\n\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(nameImportTX, network.layer1);\n      var signingTxB = fundTransaction(txB, importerAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, importerKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates an announce transaction\r\n * @param {String} messageHash - the hash of the message to send.  Should be\r\n *  an already-announced zone file hash\r\n * @param {String | TransactionSigner} senderKeyIn - the private key\r\n *  that pays for the transaction.  Should be the key that owns the\r\n *  name that the message recipients subscribe to\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n * transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n * this function does not perform the requisite safety checks -- please see the\r\n * safety module for those.\r\n * @private\r\n */\n\n\nfunction makeAnnounce(messageHash, senderKeyIn) {\n  var buildIncomplete = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var network = config_1.config.network;\n  var announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n  var senderKey = getTransactionSigner(senderKeyIn);\n  return senderKey.getAddress().then(function (senderAddress) {\n    return Promise.all([network.getUTXOs(senderAddress), network.getFeeRate()]).then(function (_ref43) {\n      var _ref44 = _slicedToArray(_ref43, 2),\n          utxos = _ref44[0],\n          feeRate = _ref44[1];\n\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(announceTX, network.layer1);\n      var signingTxB = fundTransaction(txB, senderAddress, utxos, feeRate, 0);\n      return utils_1.signInputs(signingTxB, senderKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates a token-transfer transaction\r\n * @param {String} recipientAddress - the address to receive the tokens\r\n * @param {String} tokenType - the type of tokens to send\r\n * @param {Object} tokenAmount - the BigInteger encoding of an unsigned 64-bit number of\r\n *  tokens to send\r\n * @param {String} scratchArea - an arbitrary string to include with the transaction\r\n * @param {String | TransactionSigner} senderKeyIn - the hex-encoded private key to send\r\n *   the tokens\r\n * @param {String | TransactionSigner} btcFunderKeyIn - the hex-encoded private key to fund\r\n *   the bitcoin fees for the transaction. Optional -- if not passed, will attempt to\r\n *   fund with sender key.\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n *   transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n * This function does not perform the requisite safety checks -- please see the\r\n * safety module for those.\r\n * @private\r\n */\n\n\nfunction makeTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderKeyIn, btcFunderKeyIn) {\n  var buildIncomplete = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var network = config_1.config.network;\n  var separateFunder = !!btcFunderKeyIn;\n  var senderKey = getTransactionSigner(senderKeyIn);\n  var btcKey = btcFunderKeyIn ? getTransactionSigner(btcFunderKeyIn) : senderKey;\n  var txPromise = network.getConsensusHash().then(function (consensusHash) {\n    return skeletons_1.makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea);\n  });\n  return Promise.all([senderKey.getAddress(), btcKey.getAddress()]).then(function (_ref45) {\n    var _ref46 = _slicedToArray(_ref45, 2),\n        senderAddress = _ref46[0],\n        btcAddress = _ref46[1];\n\n    var btcUTXOsPromise = separateFunder ? network.getUTXOs(btcAddress) : Promise.resolve([]);\n    return Promise.all([network.getUTXOs(senderAddress), btcUTXOsPromise, network.getFeeRate(), txPromise]).then(function (_ref47) {\n      var _ref48 = _slicedToArray(_ref47, 4),\n          senderUTXOs = _ref48[0],\n          btcUTXOs = _ref48[1],\n          feeRate = _ref48[2],\n          tokenTransferTX = _ref48[3];\n\n      var txB = bitcoinjs_lib_1.default.TransactionBuilder.fromTransaction(tokenTransferTX, network.layer1);\n\n      if (separateFunder) {\n        var payerInput = addOwnerInput(senderUTXOs, senderAddress, txB);\n        var signingTxB = fundTransaction(txB, btcAddress, btcUTXOs, feeRate, payerInput.value);\n        return utils_1.signInputs(signingTxB, btcKey, [{\n          index: payerInput.index,\n          signer: senderKey\n        }]);\n      } else {\n        var _signingTxB = fundTransaction(txB, senderAddress, senderUTXOs, feeRate, 0);\n\n        return utils_1.signInputs(_signingTxB, senderKey);\n      }\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n/**\r\n * Generates a bitcoin spend to a specified address. This will fund up to `amount`\r\n *   of satoshis from the payer's UTXOs. It will generate a change output if and only\r\n *   if the amount of leftover change is *greater* than the additional fees associated\r\n *   with the extra output. If the requested amount is not enough to fund the transaction's\r\n *   associated fees, then this will reject with a InvalidAmountError\r\n *\r\n * UTXOs are selected largest to smallest, and UTXOs which cannot fund the fees associated\r\n *   with their own input will not be included.\r\n *\r\n * If you specify an amount > the total balance of the payer address, then this will\r\n *   generate a maximum spend transaction\r\n *\r\n * @param {String} destinationAddress - the address to receive the bitcoin payment\r\n * @param {String | TransactionSigner} paymentKeyIn - the private key\r\n *    used to fund the bitcoin spend\r\n * @param {number} amount - the amount in satoshis for the payment address to\r\n *    spend in this transaction\r\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\r\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\r\n * transaction. Useful for passing around a TX for multi-sig input signing.\r\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\r\n * @private\r\n */\n\n\nfunction makeBitcoinSpend(destinationAddress, paymentKeyIn, amount) {\n  var buildIncomplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (amount <= 0) {\n    return Promise.reject(new errors_1.InvalidParameterError('amount', 'amount must be greater than zero'));\n  }\n\n  var network = config_1.config.network;\n  var paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(function (paymentAddress) {\n    return Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(function (_ref49) {\n      var _ref50 = _slicedToArray(_ref49, 2),\n          utxos = _ref50[0],\n          feeRate = _ref50[1];\n\n      var txB = new bitcoinjs_lib_1.default.TransactionBuilder(network.layer1);\n      txB.setVersion(1);\n      var destinationIndex = txB.addOutput(destinationAddress, 0); // will add utxos up to _amount_ and return the amount of leftover _change_\n\n      var change;\n\n      try {\n        change = utils_1.addUTXOsToFund(txB, utxos, amount, feeRate, false);\n      } catch (err) {\n        if (err.name === 'NotEnoughFundsError') {\n          // actual amount funded = amount requested - remainder\n          amount -= err.leftToFund;\n          change = 0;\n        } else {\n          throw err;\n        }\n      }\n\n      var feesToPay = feeRate * utils_1.estimateTXBytes(txB, 0, 0);\n      var feeForChange = feeRate * utils_1.estimateTXBytes(txB, 0, 1) - feesToPay; // it's worthwhile to add a change output\n\n      if (change > feeForChange) {\n        feesToPay += feeForChange;\n        txB.addOutput(paymentAddress, change);\n      } // now let's compute how much output is leftover once we pay the fees.\n\n\n      var outputAmount = amount - feesToPay;\n\n      if (outputAmount < utils_1.DUST_MINIMUM) {\n        throw new errors_1.InvalidAmountError(feesToPay, amount);\n      } // we need to manually set the output values now\n\n\n      var txInner = utils_1.getTransactionInsideBuilder(txB);\n      txInner.outs[destinationIndex].value = outputAmount; // ready to sign.\n\n      return utils_1.signInputs(txB, paymentKey);\n    });\n  }).then(function (signingTxB) {\n    return returnTransactionHex(signingTxB, buildIncomplete);\n  });\n}\n\nexports.transactions = {\n  makeRenewal: makeRenewal,\n  makeUpdate: makeUpdate,\n  makePreorder: makePreorder,\n  makeRegister: makeRegister,\n  makeTransfer: makeTransfer,\n  makeRevoke: makeRevoke,\n  makeNamespacePreorder: makeNamespacePreorder,\n  makeNamespaceReveal: makeNamespaceReveal,\n  makeNamespaceReady: makeNamespaceReady,\n  makeBitcoinSpend: makeBitcoinSpend,\n  makeNameImport: makeNameImport,\n  makeAnnounce: makeAnnounce,\n  makeTokenTransfer: makeTokenTransfer,\n  BlockstackNamespace: skeletons_1.BlockstackNamespace,\n  estimatePreorder: estimatePreorder,\n  estimateRegister: estimateRegister,\n  estimateTransfer: estimateTransfer,\n  estimateUpdate: estimateUpdate,\n  estimateRenewal: estimateRenewal,\n  estimateRevoke: estimateRevoke,\n  estimateNamespacePreorder: estimateNamespacePreorder,\n  estimateNamespaceReveal: estimateNamespaceReveal,\n  estimateNamespaceReady: estimateNamespaceReady,\n  estimateNameImport: estimateNameImport,\n  estimateAnnounce: estimateAnnounce,\n  estimateTokenTransfer: estimateTokenTransfer\n};","map":null,"metadata":{},"sourceType":"script"}